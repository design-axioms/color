import {
  copyFileSync,
  existsSync,
  mkdirSync,
  readFileSync,
  watch,
  writeFileSync,
} from "node:fs";
import { dirname, join, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { toTypeScriptMetadata } from "../../lib/exporters/metadata.ts";
import { generateTokensCss } from "../../lib/generator/index.ts";
import { resolveConfig, solve } from "../../lib/index.ts";
import type { SolverConfig } from "../../lib/types.ts";

type ClassTokenManifest = {
  schemaVersion: 1;
  sourceConfigPath: string;
  generatedCssPath: string;
  reservedPrefixes: string[];
  classTokens: string[];
};

function extractCssClassTokens(css: string): string[] {
  const tokens = new Set<string>();
  const re = /(^|[^a-zA-Z0-9_-])\.([a-zA-Z_][a-zA-Z0-9_-]*)/g;
  let match: RegExpExecArray | null;
  while ((match = re.exec(css)) !== null) {
    const token = match[2];
    if (token) tokens.add(token);
  }
  return [...tokens].sort();
}

function findEngineCssPath(): string | null {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);

  const candidates = [
    resolve(__dirname, "../../../css/engine.css"),
    resolve(__dirname, "../../css/engine.css"),
    resolve(__dirname, "../css/engine.css"),
  ];

  for (const candidate of candidates) {
    if (existsSync(candidate)) return candidate;
  }
  return null;
}

const RESERVED_PREFIXES = [
  "surface",
  "text",
  "hue",
  "bg",
  "border",
  "shadow",
  "fg",
  "preset",
];

export function buildCommand(args: string[], cwd: string): void {
  let configPath = "color-config.json";
  let outPath = "theme.css";
  let isWatch = false;
  let copyEngine = false;
  let emitTs = false;

  for (let i = 0; i < args.length; i++) {
    const nextArg = args[i + 1];
    if (args[i] === "--config" && nextArg) {
      configPath = nextArg;
      i++;
    } else if (args[i] === "--out" && nextArg) {
      outPath = nextArg;
      i++;
    } else if (args[i] === "--watch") {
      isWatch = true;
    } else if (args[i] === "--copy-engine") {
      copyEngine = true;
    } else if (args[i] === "--emit-ts") {
      emitTs = true;
    }
  }

  const absConfigPath = resolve(cwd, configPath);
  const absOutPath = resolve(cwd, outPath);

  const build = (): void => {
    console.log(`Reading config from: ${absConfigPath}`);
    let rawConfig: Partial<SolverConfig>;
    try {
      rawConfig = JSON.parse(
        readFileSync(absConfigPath, "utf8"),
      ) as Partial<SolverConfig>;
    } catch (e) {
      console.error(`Error reading config file: ${String(e)}`);
      if (!isWatch) process.exit(1);
      return;
    }

    const config = resolveConfig(rawConfig);

    console.log("Solving surfaces...");
    const theme = solve(config);

    console.log("Generating CSS...");
    let css = `/*
 * -----------------------------------------------------------------------------
 * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT MANUALLY.
 *
 * Generated by @axiomatic-design/color
 * Source: ${configPath}
 * -----------------------------------------------------------------------------
 */

`;

    css += generateTokensCss(
      config.groups,
      theme,
      config.borderTargets,
      config.options,
      config.anchors.keyColors,
      config.presets,
    );

    /* 
       DEPRECATED: High Contrast Theme Generation
       We now handle High Contrast via "Gain" tokens generated in the single pass above.
       The "Theme Swapping" approach is rejected in favor of the Unified State Tuple.
    */

    console.log("Writing CSS to:", absOutPath);
    mkdirSync(dirname(absOutPath), { recursive: true });
    writeFileSync(absOutPath, css);

    // Emit the solver-derived token manifest next to the CSS output.
    // This is intended to be the canonical source for per-config strict RFC010 enforcement
    // and for downstream tooling (e.g. editor completions).
    const tokensOutPath = absOutPath.endsWith(".css")
      ? absOutPath.replace(/\.css$/u, ".class-tokens.json")
      : `${absOutPath}.class-tokens.json`;

    const manifest: ClassTokenManifest = {
      schemaVersion: 1,
      sourceConfigPath: configPath,
      generatedCssPath: outPath,
      reservedPrefixes: RESERVED_PREFIXES,
      classTokens: (() => {
        const themeTokens = extractCssClassTokens(css);
        const enginePath = findEngineCssPath();
        if (!enginePath) return themeTokens;

        const engineCss = readFileSync(enginePath, "utf8");
        const engineTokens = extractCssClassTokens(engineCss);
        return [...new Set([...engineTokens, ...themeTokens])].sort();
      })(),
    };

    writeFileSync(tokensOutPath, JSON.stringify(manifest, null, 2) + "\n");
    console.log("Writing class-token manifest to:", tokensOutPath);

    if (copyEngine) {
      const __filename = fileURLToPath(import.meta.url);
      const __dirname = dirname(__filename);

      // Try to find engine.css in likely locations
      const candidates = [
        resolve(__dirname, "../../../css/engine.css"),
        resolve(__dirname, "../../css/engine.css"),
        resolve(__dirname, "../css/engine.css"),
      ];

      let enginePath: string | null = null;
      for (const candidate of candidates) {
        if (existsSync(candidate)) {
          enginePath = candidate;
          break;
        }
      }

      if (enginePath) {
        const engineOutPath = join(dirname(absOutPath), "engine.css");
        console.log("Copying engine.css to:", engineOutPath);
        copyFileSync(enginePath, engineOutPath);
      } else {
        console.warn("Warning: Could not find engine.css to copy.");
      }
    }

    if (emitTs) {
      const tsOutPath = absOutPath.endsWith(".css")
        ? absOutPath.replace(/\.css$/u, ".generated.ts")
        : `${absOutPath}.generated.ts`;
      const metadata = toTypeScriptMetadata(theme, { source: configPath });
      mkdirSync(dirname(tsOutPath), { recursive: true });
      try {
        writeFileSync(tsOutPath, metadata);
        console.log("Writing TypeScript metadata to:", tsOutPath);
      } catch (error) {
        console.error(
          `Failed to write TypeScript metadata to ${tsOutPath}:`,
          error instanceof Error ? error.message : error,
        );
        throw error;
      }
    }

    console.log("Done!");
  };

  build();

  if (isWatch) {
    console.log(`Watching for changes in ${absConfigPath}...`);
    watch(absConfigPath, (eventType) => {
      if (eventType === "change") {
        console.log("Config changed, rebuilding...");
        build();
      }
    });
  }
}
