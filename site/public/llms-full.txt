# Axiomatic Color - Full Documentation

## Axioms

# The Constitution (Axioms)

> **Status**: Living Document
> **Version**: 2.0 (Epoch 30)

This document serves as the "Constitution" for Axiomatic Color. It consolidates the core philosophy, physical laws, and architectural rules that govern the system. All design decisions and code changes must align with these axioms.

## Vision

**Axiomatic Color is a Physics Engine for Design.**

We are not building a "Paint Set" (a collection of static colors). We are building a **Deterministic System** that generates accessible, harmonious, and adaptive interfaces from semantic intent.

- **Input**: Semantic Intent + Context.
- **Process**: Algorithmic Solver (Accessibility Constraints + Optical Physics).
- **Output**: Adaptive, Accessible, Harmonious UI.

## The Axioms

The axioms are organized into domains:

### [0. The Fundamental Theorem](axioms/00-fundamental-theorem.md)

**Color = f(Context, Intent)**
Color is not a static value; it is a function. The system is a reactive dependency graph that resolves pixel values based on semantic intent and environmental context.

### [I. The Prime Directive](axioms/01-accessibility.md)

**Accessibility is the Foundation of Aesthetics.**
We reject the idea that accessibility and aesthetics are in conflict. Accessibility is the mathematical constraint solver that generates the palette.

### [II. The Laws of Physics (Light)](axioms/02-physics.md)

**Lightness is Relative. Chroma is Expensive. Hue Rotates.**
We model color as a physical phenomenon, respecting the non-linear nature of human perception (Bezold-Brücke effect, Gamut Cusps).

### [III. The Laws of Architecture (Surfaces)](axioms/03-architecture.md)

**Surfaces are Containers. Context Flows Down. Text is Relative.**
We organize UI elements into a strict taxonomy of Surfaces that establish Context for their children.

### [IV. The Laws of Integration](axioms/04-integration.md)

**Code is Truth. No Magic Numbers. Baseline Newly Available. Standard CSS First.**
We ensure consistency and interoperability by deriving everything from configuration and targeting modern web standards. We use build tools only for bundling and optimization, not for language extension.

### [V. The Laws of Engineering](axioms/05-engineering.md)

**State is a Domain Model. Testing is a Ratchet. Late Binding.**
We build maintainable, testable software that leverages the power of the browser's CSS engine for dynamic resolution.

### [VI. The Law of Static Projection](axioms/06-projection.md)

**Static exports are snapshots.**
Since the system is dynamic, any static export (JSON, PDF) is a lossy projection of the system's state at a specific moment. We must enumerate states explicitly in these formats.

### [VII. The Law of Determinism](axioms/07-determinism.md)

**Given the same configuration, the output must be bit-for-bit identical.**
We rely on Golden Master testing to ensure that the "Physics Engine" does not drift silently.

### [VIII. The Law of Lossless Interoperability](axioms/08-interoperability.md)

**We export to other formats without losing semantic meaning.**
We prioritize formats that preserve the semantics of the system (like reactive CSS variables in Tailwind) over flattened values.

### [IX. The Law of "Just Enough" Configuration](axioms/09-configuration.md)

**We expose knobs for _intent_, not _implementation_.**
Users express what they want (Accessibility, Vibe), and the system handles the math.

### [X. The Law of Semantic Continuity](axioms/10-semantic-continuity.md)

**Transitions must preserve semantic intent, not just minimize distance.**
We reject linear interpolation when it violates the semantic meaning of the transition (e.g., forcing a "Cool -> Warm" hue shift to go the long way around the wheel).

### [XI. The Law of the Stable Spine](axioms/11-stable-spine.md)

**Keep the spine generic. Push variability to the edges.**
We prevent “glue drift” by keeping orchestrators branch-free and pushing configuration, analysis, and output policies into typed module hooks.

## Missing / Implicit Axioms (To Be Formalized)

The following principles guide our work but have not yet been codified into Law:

- (None currently)

---

## advanced/bridge-api.mdx

This page describes the adapter **bridge API**: a narrow seam intended for integrating Axiomatic Color into a host system that already owns its palette variables and chrome.

Most consumers should *not* use bridge exports directly. Prefer semantic classes and exported tokens.

## See also

- [Integration](/guides/integration)

## What the bridge exports are

Bridge exports are a small set of CSS custom properties in the `--axm-bridge-*` family that adapters may read.

They exist to avoid two bad outcomes:

- depending on engine internals (`--axm-*` / `--_axm-*`), and
- spreading host-specific overrides throughout authored components.

## One-file rule

All host-variable integration should live in a **single adapter stylesheet** (a “bridge file”). That file is the only place where host variables and bridge wiring belong.

## Example mapping (conceptual)

{/* axm-docs:explanatory:start */}

```css
/* Adapter stylesheet (single boundary file) */
:root {
  /* Map host palette variables into Axiomatic bridge exports */
  --host-color-text: var(--axm-bridge-fg);
  --host-color-border: var(--axm-bridge-border-int);
  --host-color-hairline: var(--axm-bridge-border-dec);
}
```

{/* axm-docs:explanatory:end */}

## Continuity constraints (non-negotiable)

The bridge exports must not become a second animation driver.

- Do not transition `--axm-bridge-*`.
- Do not transition `border-color` in chrome while borders are bridge-routed.
- Do not use `border: … currentColor` for chrome borders; route borders through bridge exports (for example `--axm-bridge-border-int`).

These rules prevent “popping” where some chrome regions update on different ticks than the engine-driven transition.

---

## advanced/composition-algebra.mdx

> **Context**: The physics and grammar of the Axiomatic Color system.

This document defines the "Physics" of the Axiomatic Color system. While the system is built on rigorous math, you can think of it using a simple grammatical analogy:

- **Context (<math><mi>H</mi><mo>,</mo><mi>C</mi></math>) is the Setting**: It's the lighting in the room. If the room is red, everything inside is tinted red. This "atmosphere" permeates everything.
- **Intent (<math><mi>L</mi></math>) is the Voice**: It's how loud you are speaking. You can whisper (Subtle) or shout (High).
- **Surfaces are Scene Changes**: When you walk into a new room (a Card, a Sidebar), the conversation resets. You stop shouting, but the lighting might stay the same.

Below, we formalize these intuitions into a set of rules that guarantee your UI always looks consistent.

## 1. The State Space (<math><mi mathvariant="normal">Σ</mi></math>)

The system state at any point in the DOM tree is defined by a vector <math><mi mathvariant="normal">Σ</mi></math>.

<math display="block">
  <mrow>
    <mi mathvariant="normal">Σ</mi>
    <mo>=</mo>
    <mo stretchy="false">⟨</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo>,</mo>
    <msub>
      <mi>L</mi>
      <mi mathvariant="italic">src</mi>
    </msub>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">⟩</mo>
  </mrow>
</math>

<DemoWrapper>
  <Diagram>
    <StateVectorExplainer client:load />
  </Diagram>
</DemoWrapper>

:::tip[In Plain English]
Think of <math><mi mathvariant="normal">Σ</mi></math> as the "DNA" of the current element. It carries four genes: what color family we are in (<math><mi>H</mi></math>), how vibrant it is (<math><mi>C</mi></math>), how bright the text should be (<math><msub><mi>L</mi><mi mathvariant="italic">src</mi></msub></math>), and whether we are in light or dark mode (<math><mi>α</mi></math>). Every element inherits this DNA from its parent.
:::

## 2. The Resolution Function (<math><mi mathvariant="normal">Φ</mi></math>)

The CSS Engine acts as a projection function <math><mi mathvariant="normal">Φ</mi></math> that maps the state vector <math><mi mathvariant="normal">Σ</mi></math> to a concrete CSS color value.

<math display="block">
  <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">↦</mo>
    <mtext>ColorSpace</mtext>
    <mo stretchy="false">(</mo>
    <mtext>oklch</mtext>
    <mo stretchy="false">)</mo>
  </mrow>
</math>

<math display="block">
  <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">⟨</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo>,</mo>
    <msub>
      <mi>L</mi>
      <mi mathvariant="italic">src</mi>
    </msub>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">⟩</mo>
    <mo stretchy="false">)</mo>
    <mo>=</mo>
    <mtext>oklch</mtext>
    <mo stretchy="false">(</mo>
    <mtext>eval</mtext>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>L</mi>
      <mi mathvariant="italic">src</mi>
    </msub>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
    <mo>,</mo>
    <mi>C</mi>
    <mo>,</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math>

Where <math><mtext>eval</mtext><mo stretchy="false">(</mo><msub><mi>L</mi><mi mathvariant="italic">src</mi></msub><mo>,</mo><mi>α</mi><mo stretchy="false">)</mo></math> represents the **Late Binding** of the token. It is a lookup function into the token definition set:

<math display="block">
  <mrow>
    <mo>∀</mo>
    <mi>t</mi>
    <mo>∈</mo>
    <mtext>Tokens</mtext>
    <mo>,</mo>
    <mo>∃</mo>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>l</mi>
      <mi mathvariant="italic">light</mi>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>l</mi>
      <mi mathvariant="italic">dark</mi>
    </msub>
    <mo stretchy="false">)</mo>
    <mtext> s.t. </mtext>
    <mtext>eval</mtext>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
    <mo>=</mo>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>=</mo>
    <mtext>Dark</mtext>
    <mo stretchy="false">)</mo>
    <mo>?</mo>
    <msub>
      <mi>l</mi>
      <mi mathvariant="italic">dark</mi>
    </msub>
    <mo>:</mo>
    <msub>
      <mi>l</mi>
      <mi mathvariant="italic">light</mi>
    </msub>
  </mrow>
</math>

:::tip[In Plain English]

<math>
  <mi mathvariant="normal">Φ</mi>
</math>
is the browser's rendering engine. It takes the DNA (
<math>
  <mi mathvariant="normal">Σ</mi>
</math>
) and turns it into actual pixels. Crucially, it decides the actual lightness
_at the last moment_ based on whether we are in light or dark mode. :::

## 3. The Operators

Classes in the system are **Operators** that transform the state vector <math><mi mathvariant="normal">Σ</mi><mo stretchy="false">→</mo><msup><mi mathvariant="normal">Σ</mi><mo>′</mo></msup></math>.

### 3.1. Surface Operator (<math><mi>S</mi></math>)

A Surface establishes a new context. It acts as an **Identity** for Context (<math><mi>H</mi><mo>,</mo><mi>C</mi></math>) but a **Lossy Barrier** for Intent (<math><msub><mi>L</mi><mi mathvariant="italic">src</mi></msub></math>).

<math display="block">
  <mrow>
    <msub>
      <mi>S</mi>
      <mi mathvariant="italic">type</mi>
    </msub>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">⟨</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo>,</mo>
    <msub>
      <mi>L</mi>
      <mi mathvariant="italic">src</mi>
    </msub>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">⟩</mo>
    <mo stretchy="false">)</mo>
    <mo>=</mo>
    <mo stretchy="false">⟨</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo>,</mo>
    <msub>
      <mi>L</mi>
      <mi mathvariant="italic">high</mi>
    </msub>
    <mo>,</mo>
    <msup>
      <mi>α</mi>
      <mo>′</mo>
    </msup>
    <mo stretchy="false">⟩</mo>
  </mrow>
</math>

- **Context Stability**: <math><mi>H</mi></math> and <math><mi>C</mi></math> are preserved (Identity). The surface inherits the ambient atmosphere of its parent.
- **Intent Erasure**: <math><msub><mi>L</mi><mi mathvariant="italic">src</mi></msub></math> is forcibly reset to <math><msub><mi>L</mi><mi mathvariant="italic">high</mi></msub></math>. This operation is **Non-Invertible** (you cannot "undo" a surface to recover the parent's text style).
- **Polarity**: <math><mi>α</mi></math> is transformed. For standard surfaces, <math><msup><mi>α</mi><mo>′</mo></msup><mo>=</mo><mi>α</mi></math>. For inverted surfaces, <math><msup><mi>α</mi><mo>′</mo></msup><mo>=</mo><mo>¬</mo><mi>α</mi></math> (Hard Flip).

:::tip[In Plain English]
A Surface is like a glass box. It lets the "mood lighting" (Hue/Chroma) shine through from the outside, but it resets the "conversation" (Text). Inside the box, you start a new sentence with standard text color, even if the text outside was faint or bold.
:::

<DemoWrapper>
  <Diagram>
    <SurfaceOperatorDemo client:load />
  </Diagram>
</DemoWrapper>

> **Rationalization: Ambient vs. Semantic State**
>
> We can rationalize this behavior by distinguishing between two types of state:
>
> 1.  **Environmental State (<math><mi>H</mi><mo>,</mo><mi>C</mi></math>)**: This behaves like **Ambient Light**. If a room is lit with red light, objects inside (Surfaces) should reflect that red tint. The atmosphere permeates boundaries.
> 2.  **Semantic State (<math><msub><mi>L</mi><mi mathvariant="italic">src</mi></msub></math>)**: This behaves like **Grammar**. A "Card" is a new sentence. Just because the previous sentence ended quietly (Subtle) doesn't mean the new sentence (Card Title) should start quietly. The grammar resets at the boundary of the object.

### 3.2. Intent Operator (<math><mi>I</mi></math>)

Intent classes (e.g., `.text-subtle`) modify the Lightness Source.

<math display="block">
  <mrow>
    <msub>
      <mi>I</mi>
      <mi mathvariant="italic">token</mi>
    </msub>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">⟨</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo>,</mo>
    <msub>
      <mi>L</mi>
      <mi mathvariant="italic">src</mi>
    </msub>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">⟩</mo>
    <mo stretchy="false">)</mo>
    <mo>=</mo>
    <mo stretchy="false">⟨</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo>,</mo>
    <msub>
      <mi>L</mi>
      <mi mathvariant="italic">token</mi>
    </msub>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">⟩</mo>
  </mrow>
</math>

- **Identity on Context**: <math><mi>H</mi></math> and <math><mi>C</mi></math> are preserved.
- **Action**: Updates <math><msub><mi>L</mi><mi mathvariant="italic">src</mi></msub></math>.

:::tip[In Plain English]
Intent classes like `.text-subtle` only change _one_ thing: the lightness reference. They don't touch the color. They say "make this text dimmer," regardless of whether it's blue, red, or purple.
:::

### 3.3. Modifier Operator (<math><mi>M</mi></math>)

Modifier classes (e.g., `.hue-brand`) modify the Context variables.

<math display="block">
  <mrow>
    <msub>
      <mi>M</mi>
      <mi mathvariant="italic">brand</mi>
    </msub>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">⟨</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo>,</mo>
    <msub>
      <mi>L</mi>
      <mi mathvariant="italic">src</mi>
    </msub>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">⟩</mo>
    <mo stretchy="false">)</mo>
    <mo>=</mo>
    <mo stretchy="false">⟨</mo>
    <msub>
      <mi>H</mi>
      <mi mathvariant="italic">brand</mi>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>C</mi>
      <mi mathvariant="italic">ambient</mi>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>L</mi>
      <mi mathvariant="italic">src</mi>
    </msub>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">⟩</mo>
  </mrow>
</math>

- **Identity on Intent**: <math><msub><mi>L</mi><mi mathvariant="italic">src</mi></msub></math> is preserved.
- **Context Definition**: Updates <math><mi>H</mi></math> to the brand hue. Updates <math><mi>C</mi></math> to the **Ambient Chroma** (<math><msub><mi>C</mi><mi mathvariant="italic">ambient</mi></msub><mo>≈</mo><mn>0.1</mn><mo>×</mo><msub><mi>C</mi><mi mathvariant="italic">brand</mi></msub></math>).

:::tip[In Plain English]
Modifier classes like `.hue-brand` change the atmosphere. They say "everything inside here should be purple," but they don't touch the text hierarchy. A title is still a title, just purple now. This is also where the "Dampening" happens: the modifier takes a vibrant brand color and creates a soft ambient version for backgrounds.
:::

## 4. Laws of Composition

### 4.1. Orthogonality (Commutativity of <math><mi>I</mi></math> and <math><mi>M</mi></math>)

Because Intent (<math><mi>I</mi></math>) and Modifiers (<math><mi>M</mi></math>) operate on disjoint components of the state vector, they are commutative.

<math display="block">
  <mrow>
    <mi>I</mi>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo>≡</mo>
    <mi>M</mi>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
  </mrow>
</math>

**Implication**: The order of classes in HTML (`class="text-subtle hue-brand"` vs `class="hue-brand text-subtle"`) does not matter for the resulting color.

:::tip[In Plain English]
Because `.text-subtle` only touches Lightness, and `.hue-brand` only touches Color, they don't step on each other's toes. You can combine them in any order, and the result is always "Subtle Brand Color".
:::

<DemoWrapper>
  <Diagram>
    <OrthogonalityGrid client:load />
  </Diagram>
</DemoWrapper>

### 4.2. Surface Dominance

A Surface (<math><mi>S</mi></math>) resets the local intent. Therefore, an Intent applied _outside_ a surface does not penetrate _into_ the surface's default text.

<math display="block">
  <mrow>
    <mtext>Inside Surface: </mtext>
    <mi mathvariant="normal">Φ</mi>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo>≠</mo>
    <mi mathvariant="normal">Φ</mi>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
  </mrow>
</math>

- <math>
    <mi>S</mi>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
  </math>
  : The surface resets the intent. The outer intent is lost.
- <math>
    <mi>I</mi>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
  </math>
  : The intent is applied _to_ the surface's context.

**Implication**: You must apply text utilities _inside_ or _on_ the element that needs them.

:::tip[In Plain English]
Surfaces are barriers. If you make a container "subtle", and then put a Card inside it, the text inside the Card goes back to normal. The Card protects its contents from the outside world's text styles.
:::

## 5. Invariants

### 5.1. Contrast Preservation

Modifiers (<math><mi>M</mi></math>) are **Contrast Preserving**.

<math display="block">
  <mrow>
    <mtext>Contrast</mtext>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Φ</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo>,</mo>
    <mtext>Background</mtext>
    <mo stretchy="false">)</mo>
    <mo>≈</mo>
    <mtext>Contrast</mtext>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Φ</mi>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo>,</mo>
    <mtext>Background</mtext>
    <mo stretchy="false">)</mo>
  </mrow>
</math>

Since <math><mi>M</mi></math> only changes <math><mi>H</mi></math> and <math><mi>C</mi></math>, and OKLCH is perceptually uniform, the perceived lightness (and thus contrast against the background) remains constant.

:::tip[In Plain English]
Changing the hue (e.g., adding `.hue-brand`) never breaks accessibility. If the text was readable before, it stays readable, because the system only changes the color, not the brightness.
:::

<DemoWrapper>
  <Diagram>
    <ContrastStabilityDemo client:load />
  </Diagram>
</DemoWrapper>

### 5.2. Intent Stability

Intent (<math><mi>I</mi></math>) is **Chromatically Transparent**.

<math display="block">
  <mrow>
    <mtext>Hue</mtext>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Φ</mi>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo>=</mo>
    <mtext>Hue</mtext>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Φ</mi>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
  </mrow>
</math>

Changing the text importance (High -> Subtle) never shifts the hue.

:::tip[In Plain English]
Changing the text style (e.g., making it `.text-subtle`) never changes its color family. If you are in a "Brand" section, the subtle text will still be tinted with the brand color, just dimmer. The text style doesn't "reset" the color to gray.
:::

## 6. Practical Application

This algebra proves that we can support <math><mi>N</mi></math> intents and <math><mi>M</mi></math> contexts with <math><mi>N</mi><mo>+</mo><mi>M</mi></math> classes, rather than <math><mi>N</mi><mo>×</mo><mi>M</mi></math> classes.

- **Traditional**: `.text-subtle-on-brand`, `.text-subtle-on-neutral`
- **Axiomatic**: `.text-subtle` + `.hue-brand`

The resolution happens at render time via the <math><mi mathvariant="normal">Φ</mi></math> function (the CSS Engine).

## 7. Implications & Corollaries

### 7.1. Idempotency of Modifiers

Applying the same modifier twice is equivalent to applying it once.

<math display="block">
  <mrow>
    <msub>
      <mi>M</mi>
      <mi mathvariant="italic">brand</mi>
    </msub>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>M</mi>
      <mi mathvariant="italic">brand</mi>
    </msub>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo>≡</mo>
    <msub>
      <mi>M</mi>
      <mi mathvariant="italic">brand</mi>
    </msub>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math>

This means nesting a `.hue-brand` section inside another `.hue-brand` section is safe and redundant.

### 7.2. The "Leakage" Corollary

If a container does _not_ act as a Surface (<math><mi>S</mi></math>), it does not reset <math><msub><mi>L</mi><mi mathvariant="italic">src</mi></msub></math>.

<math display="block">
  <mrow>
    <mtext>Container</mtext>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>I</mi>
      <mi mathvariant="italic">subtle</mi>
    </msub>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">→</mo>
    <mtext>Text is still subtle inside</mtext>
  </mrow>
</math>

This distinguishes **Layout Containers** (divs, spans) from **Surfaces** (cards, sidebars). Surfaces are opaque boundaries for Intent; Containers are transparent.

### 7.3. Universal Theming

Since <math><mi>M</mi></math> operators control the environment (<math><mi>H</mi><mo>,</mo><mi>C</mi></math>) for all child elements, changing the top-level modifier effectively re-themes the entire subtree without requiring changes to the leaf nodes (text, borders).

### 7.4. The Portal Effect (Subspace Involution)

Because Inverted Surfaces perform a Hard Flip (<math><msup><mi>α</mi><mo>′</mo></msup><mo>=</mo><mo>¬</mo><mi>α</mi></math>), nesting them creates an alternating polarity stack. However, because <math><mi>S</mi></math> is lossy on Intent (<math><mi>L</mi></math>), this is not a true inverse of the state.

<math display="block">
  <mrow>
    <msub>
      <mi>S</mi>
      <mi mathvariant="italic">inv</mi>
    </msub>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>S</mi>
      <mi mathvariant="italic">inv</mi>
    </msub>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">)</mo>
    <mo stretchy="false">)</mo>
    <mo>≠</mo>
    <mi mathvariant="normal">Σ</mi>
  </mrow>
</math>

While the polarity returns to the original (<math><mo>¬</mo><mo stretchy="false">(</mo><mo>¬</mo><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><mi>α</mi></math>), the Intent <math><msub><mi>L</mi><mi mathvariant="italic">src</mi></msub></math> is reset to <math><msub><mi>L</mi><mi mathvariant="italic">high</mi></msub></math> at each step. You recover the _mode_, but you lose the _semantic context_.

<DemoWrapper>
  <Diagram>
    <PortalStack client:load />
  </Diagram>
</DemoWrapper>

---

## advanced/custom-surfaces.md

Coming soon: How to define your own semantic surfaces.

---

## advanced/font-test.mdx

<div style="font-family: 'STIX Two Math', serif; font-size: 2em; border: 1px solid red; padding: 10px;">
  Direct: ∑ = ⟨ Hue, Chroma, Intent, Polarity ⟩
</div>

<div style="font-family: var(--font-stix-two-math), serif; font-size: 2em; border: 1px solid blue; padding: 10px;">
  Variable: ∑ = ⟨ Hue, Chroma, Intent, Polarity ⟩
</div>

## MathML Test

$$
\sum = \langle \text{Hue}, \text{Chroma}, \text{Intent}, \text{Polarity} \rangle
$$

$$
x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}
$$

## Font Comparison Lab

<MathFontComparison client:load />

---

## advanced/framework-integration.mdx

This guide is for framework authors and design system engineers who need to integrate Axiomatic Color into an existing theme system with its own CSS variables.

If you're building an app, see the [Integration Guide](/guides/integration) instead.

:::tip[Reference Implementation]
For a complete working example, see the [Vercel Demo integration](https://github.com/design-axioms/color/tree/main/examples/vercel-demo) which demonstrates adapter patterns, runtime wiring, and contract enforcement.
:::

## The Problem: Two Theme Systems

You have an existing framework (e.g., Starlight, Chakra UI, Material UI) with its own color variables (`--framework-*`). You want to use Axiomatic's color engine, but your framework "owns" the DOM and injects its own styles.

**Approaches that don't work:**

- ❌ Rewrite the framework to use Axiomatic classes (too invasive)
- ❌ Override framework styles with `!important` (unmaintainable)
- ❌ Manually sync two separate theme systems (error-prone)

**The solution:**

- ✅ Create a **bridge adapter** that maps Axiomatic bridge exports to your framework's variables

## The Adapter Pattern

An adapter is a **single CSS file** that sits between Axiomatic and your framework. It maps Axiomatic's bridge exports (`--axm-bridge-*`) to your framework's color variables.

### Rules (Non-Negotiable)

1. **Single file only** — All framework integration CSS lives in ONE adapter file
2. **Bridge exports only** — Never reference engine internals (`--_axm-*` or `--axm-*`)
3. **No transitions** — Never transition bridge exports or your mapped variables
4. **No currentColor for chrome borders** — Use bridge border exports instead

These rules prevent "popping" where parts of your UI animate on different timing than the Axiomatic engine.

## Bridge Exports Reference

Axiomatic provides these stable, public CSS variables for adapters:

| Variable                   | Purpose            | Notes                           |
| -------------------------- | ------------------ | ------------------------------- |
| `--axm-bridge-surface`     | Background color   | Context-sensitive               |
| `--axm-bridge-fg`          | Generic text       | High contrast                   |
| `--axm-bridge-fg-high`     | High-emphasis text | Very high contrast              |
| `--axm-bridge-fg-body`     | Body text          | Standard reading contrast       |
| `--axm-bridge-fg-subtle`   | De-emphasized text | Lower contrast for secondary    |
| `--axm-bridge-border-int`  | Interactive border | Buttons, inputs, focus rings    |
| `--axm-bridge-border-dec`  | Decorative border  | Cards, dividers, hairlines      |

See [Bridge API (Adapters)](/advanced/bridge-api) for full reference.

## Example: Mapping Framework Variables

{/* axm-docs:explanatory:start */}

```css
/* src/styles/framework-adapter.css — THE ONLY FILE with framework mappings */
:root {
  /* Map framework backgrounds to bridge surface */
  --framework-bg-page: var(--axm-bridge-surface);
  --framework-bg-card: var(--axm-bridge-surface);

  /* Map text to bridge foreground */
  --framework-text-primary: var(--axm-bridge-fg-high);
  --framework-text-body: var(--axm-bridge-fg-body);
  --framework-text-secondary: var(--axm-bridge-fg-subtle);

  /* Map borders to bridge border exports */
  --framework-border-interactive: var(--axm-bridge-border-int);
  --framework-border-decorative: var(--axm-bridge-border-dec);
}
```

{/* axm-docs:explanatory:end */}

Now when Axiomatic's theme changes (light → dark), the bridge exports update, your framework variables update, and your components re-paint—all in one smooth transition.

## Runtime Wiring

Sometimes you need to apply Axiomatic classes to framework-owned DOM elements. Use `applyDomWiring` for declarative, idempotent wiring:

```typescript


const wiring = [
  {
    selector: ".framework-page-container",
    addClasses: ["surface-page"],
  },
  {
    selector: ".framework-card",
    addClasses: ["surface-card"],
  },
];

// Apply once on page load
applyDomWiring(wiring);
```

**Rules for runtime wiring:**

- ✅ Apply classes and attributes
- ✅ Wrap elements in containers
- ❌ Do NOT read or write CSS variables in JS

## Contract Enforcement (Optional)

For frameworks with complex chrome (headers, sidebars), you can create a **contract adapter** to detect violations at test time.

### 1. Define your contract

```typescript
// contract-spec.ts
export const MY_FRAMEWORK_CONTRACT = {
  chromeSelectorHints: [".framework-header", ".framework-sidebar"],
  allowedBorderVarNames: [
    "--axm-bridge-border-int",
    "--axm-bridge-border-dec",
  ],
  forbiddenTransitionSubstrings: [
    { substring: "border-color", reason: "Causes popping" },
  ],
};
```

### 2. Create the adapter

```typescript
// contract-adapter.ts




export function createFrameworkContractAdapter(): FrameworkContractAdapter {
  return {
    name: "MyFramework",
    scan(options) {
      return scanChromeContract({
        spec: MY_FRAMEWORK_CONTRACT,
        ignoreContainer: options?.ignoreContainer,
      });
    },
  };
}
```

### 3. Use in tests

```typescript




test("framework chrome respects continuity contract", async ({ page }) => {
  await page.goto("/");

  const result = await page.evaluate(() => {
    const engine = InspectorEngine.get();
    const adapter = createFrameworkContractAdapter();
    return engine.scanForFrameworkContractViolations(adapter);
  });

  expect(result.violations).toHaveLength(0);
});
```

## Real-World Example: Starlight

The Axiomatic documentation site uses Starlight (an Astro-based docs framework) and integrates via this pattern. Key files:

- **Adapter bridge**: Maps `--sl-*` variables to `--axm-bridge-*`
- **Contract adapter**: `src/lib/integrations/starlight/contract-adapter.ts`
- **Contract tests**: `tests/starlight-chrome-border.contract.spec.ts`

## Troubleshooting

### Colors don't update smoothly

1. Are you mapping to bridge exports in **one file only**?
2. Are you transitioning `border-color` or any `--framework-*` variables?
3. Are you using `currentColor` for chrome borders?

### Inverted surfaces don't work

1. Are you using `ThemeManager` with `invertedSelectors`?
2. Is `surface-spotlight` applied to the element (via `applyDomWiring`)?
3. Does your adapter map backgrounds to `--axm-bridge-surface`?

### Native controls look wrong

ThemeManager sets `color-scheme` on inverted surfaces. If you override `color-scheme` in your framework CSS, remove it—let Axiomatic handle it.

## See Also

- [Bridge API Reference](/advanced/bridge-api)
- [Integration Guide](/guides/integration)

---

## advanced/hue-shifting.mdx

## Why Shift Hues?

This page is explanatory. You should not need to implement hue shifting yourself to use the system.

In the real world, objects rarely stay the same hue as they get lighter or darker.

- **Natural Light**: Shadows are often cooler (bluer) due to ambient skylight, while direct highlights are warmer (yellower) from the sun.
- **The Bezold–Brücke Effect**: As light intensity increases, our perception of hue shifts. Reds become yellower, and violets become bluer.

{/* axm-docs:explanatory:start */}
If you create a color palette by simply changing lightness (e.g., `oklch(0.5 0.2 260)` → `oklch(0.9 0.2 260)`), the result can feel "synthetic" or "flat". The shadows might look muddy, or the highlights might look washed out.
{/* axm-docs:explanatory:end */}

**Hue Shifting** mimics natural light physics by rotating the hue as lightness changes. This creates palettes that feel:

1.  **More Dynamic**: Colors feel alive rather than static.
2.  **More Natural**: Mimics the way light interacts with surfaces in the real world.
3.  **More Distinct**: Helps differentiate surfaces that are close in lightness.

<Diagram>
  <div class="docs-grid docs-mb-4">
    <div class="docs-card surface-card bordered">
      <strong class="docs-card-header">Static Hue (Boring)</strong>
      <div class="docs-gradient-bar docs-gradient-static"></div>
      <div class="text-subtle docs-mt-2 docs-text-sm">
        Just changing lightness. The result feels mechanical and flat.
      </div>
    </div>
    <div class="docs-card surface-card bordered">
      <strong class="docs-card-header">Shifted Hue (Dynamic)</strong>
      <div class="docs-gradient-bar docs-gradient-shifted"></div>
      <div class="text-subtle docs-mt-2 docs-text-sm">
        Rotating hue from Blue (260) to Orange (80) as lightness increases. The
        result feels more vibrant and natural.
      </div>
    </div>
  </div>
</Diagram>

## The Challenge of Linearity

While shifting hues is desirable, _how_ we shift them matters. A naive implementation might apply hue rotation linearly (e.g., 1° of rotation for every 1% of lightness).

However, this linear approach often fails to match human perception or design intent:

1.  **Drifting Shadows**: Deep shadows lose their "cool" base hue too quickly, becoming muddy or ambiguous.
2.  **Premature Warmth**: Highlights become warm too early in the lightness scale, losing the crispness of the mid-tones.

We need a way to "pin" the hue in the shadows and highlights while concentrating the shift in the mid-tones where it adds the most vibrancy.

## The Solution: Cubic Bezier Curves

To solve this, we use a **cubic Bezier curve** to map lightness values (0-1) to hue rotation factors (0-1). This creates an "S-curve" that:

1.  **Starts Slowly**: Keeps the hue stable in the deep shadows.
2.  **Accelerates**: Concentrates the shift in the mid-tones.
3.  **Ends Smoothly**: Stabilizes the hue in the bright highlights.

### Visual Comparison

The table below demonstrates a 180° hue shift (Blue → Orange) applied linearly vs. using a Bezier curve. Notice how the Bezier curve preserves the identity of the colors at the extremes.

<Diagram>
  <div class="docs-grid-comparison-v2">
    <div class="comparison-header">
      <span class="text-subtle">Linear Shift</span>
      <span class="text-subtle">Bezier Shift (S-Curve)</span>
    </div>
    
    {/* Dark (L=0.1) */}
    <div class="comparison-row">
      <div class="row-header">Dark (10%)</div>
      <div class="swatch-pair">
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-linear-1" title="Linear: +18°"></div>
          <span class="text-xs">Drifts immediately (+18°)</span>
        </div>
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-bezier-1" title="Bezier: +0°"></div>
          <span class="text-xs">Stays at base hue (+0°)</span>
        </div>
      </div>
    </div>

    {/* Dark-Mid (L=0.3) */}
    <div class="comparison-row">
      <div class="row-header">Shadow (30%)</div>
      <div class="swatch-pair">
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-linear-2" title="Linear: +54°"></div>
          <span class="text-xs">Significant shift (+54°)</span>
        </div>
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-bezier-2" title="Bezier: +15°"></div>
          <span class="text-xs">Preserves cool tones (+15°)</span>
        </div>
      </div>
    </div>

    {/* Mid (L=0.5) */}
    <div class="comparison-row">
      <div class="row-header">Mid (50%)</div>
      <div class="swatch-pair">
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-linear-3" title="Linear: +90°"></div>
          <span class="text-xs">Midpoint (+90°)</span>
        </div>
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-bezier-3" title="Bezier: +90°"></div>
          <span class="text-xs">Midpoint (+90°)</span>
        </div>
      </div>
    </div>

    {/* Light-Mid (L=0.7) */}
    <div class="comparison-row">
      <div class="row-header">Highlight (70%)</div>
      <div class="swatch-pair">
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-linear-4" title="Linear: +126°"></div>
          <span class="text-xs">Steady progression (+126°)</span>
        </div>
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-bezier-4" title="Bezier: +165°"></div>
          <span class="text-xs">Accelerates into warmth (+165°)</span>
        </div>
      </div>
    </div>

    {/* Light (L=0.9) */}
    <div class="comparison-row">
      <div class="row-header">Light (90%)</div>
      <div class="swatch-pair">
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-linear-5" title="Linear: +162°"></div>
          <span class="text-xs">Not fully rotated (+162°)</span>
        </div>
        <div class="swatch-col">
          <div class="docs-swatch docs-swatch-bezier-5" title="Bezier: +180°"></div>
          <span class="text-xs">Finishes rotation (+180°)</span>
        </div>
      </div>
    </div>

  </div>
</Diagram>

## Interactive Playground

Experiment with the Bezier curve control points to see how they affect the hue shift across the lightness spectrum.

<HueShiftVisualizer
  client:load
  baseHue={260}
  maxRotation={180}
  curve={{ p1: [0.5, 0], p2: [0.5, 1] }}
/>

## Implementation Details

The system uses a standard cubic Bezier function where the curve starts at `(0,0)` and ends at `(1,1)`.

```typescript
function cubicBezier(t: number, p1: number, p2: number): number {
  const oneMinusT = 1 - t;
  return (
    3 * oneMinusT * oneMinusT * t * p1 + 3 * oneMinusT * t * t * p2 + t * t * t
  );
}

export function calculateHueShift(
  lightness: number,
  config?: HueShiftConfig,
): number {
  if (!config) return 0;
  const { curve, maxRotation } = config;
  const factor = cubicBezier(lightness, curve.p1[1], curve.p2[1]);
  return factor * maxRotation;
}
```

### Configuration

You can customize the curve by adjusting the two control points (`p1` and `p2`) and the maximum rotation angle.

```json
{
  "hueShift": {
    "curve": {
      "p1": [0.5, 0], // Control Point 1 (x, y)
      "p2": [0.5, 1] // Control Point 2 (x, y)
    },
    "maxRotation": 180 // Total degrees of rotation
  }
}
```

- **P1**: Controls the "acceleration" out of the shadows. Moving it right delays the shift; moving it up starts the shift earlier.
- **P2**: Controls the "deceleration" into the highlights. Moving it left extends the shift; moving it down ends the shift earlier.

## Related Concepts

- **OKLCH Color Space**: Hue rotations happen in the perceptually uniform OKLCH space, ensuring equal visual impact across the spectrum.
- **Chroma Independence**: Hue shifts don't affect saturation, maintaining consistent vibrancy.
- **CSS `@property`**: Registered custom properties allow smooth animated transitions between hue-shifted values.

---

## advanced/reactive-pipeline.mdx

# The Reactive Pipeline

This page is for understanding how the system works. Most integrations should not depend on internal CSS variables; prefer the generated theme outputs and class tokens.

Most color systems are **Static Maps**. You define a palette (`blue-500`), assign it to a variable (`--primary`), and use it.

Axiomatic Color is different. It is a **Reactive Pipeline**.

## The Core Equation

If you are familiar with React, you know the formula:

$$
UI = f(State)
$$

In Axiomatic Color, we apply this same principle to design tokens:

$$
Color = f(Context, Intent)
$$

- **Context**: Where is this element? (Light Mode? Dark Mode? Inside a Card? On a Brand Surface?)
- **Intent**: What is this element? (Text? Border? Background?)
- **Color**: The final pixel value.

## Static vs. Reactive

### The Static Model (Traditional)

In a traditional system, tokens are **Values**.

{/* axm-docs:explanatory:start */}

```css
:root {
  --text-primary: #111827;
  --bg-card: #ffffff;
}

.dark {
  --text-primary: #f9fafb;
  --bg-card: #1f2937;
}
```

{/* axm-docs:explanatory:end */}

This works for simple Light/Dark switching. But what happens when you put a card _inside_ a dark section in Light Mode? You have to manually override the tokens or use complex CSS cascades.

### The Reactive Model (Axiomatic)

In Axiomatic, tokens are **Functions**.

We don't just swap values; we swap the **calculation**.

{/* axm-docs:explanatory:start */}

```css
/* Simplified for explanation */
.surface-card {
  /* 1. Establish Context */
  --context-lightness: var(--anchor-page-lightness);

  /* 2. Define the Function */
  background: oklch(var(--context-lightness) 0 0);
  color: oklch(from var(--context-lightness) calc(1 - l) 0 0);
}
```

{/* axm-docs:explanatory:end */}

When you nest a surface, the `Context` changes. The `Intent` (Text, Background) remains the same, but because the input `Context` changed, the output `Color` automatically updates.

## How It Works: Late Binding

To make this work in standard CSS, we use a technique called **Late Binding**.

Instead of resolving colors at build time (Sass/PostCSS), we resolve them at **Runtime** (Browser) using CSS Custom Properties.

### 1. The Inputs (Primitives)

We start with the raw ingredients. These are global and immutable.

{/* axm-docs:explanatory:start */}

```css
:root {
  --primitive-brand-500: oklch(0.6 0.2 250);
  --primitive-neutral-0: oklch(1 0 0);
  --primitive-neutral-1000: oklch(0 0 0);
}
```

{/* axm-docs:explanatory:end */}

### 2. The Context (State)

When you enter a surface, it sets local variables that describe the environment.

{/* axm-docs:explanatory:start */}

```css
.surface-sunken {
  /* I am a slightly darker surface */
  --context-base-lightness: 0.95;
  --context-contrast-direction: -1; /* Get darker for contrast */
}
```

{/* axm-docs:explanatory:end */}

### 3. The Resolution (Function)

Utility classes don't point to fixed colors. They point to **Logic**.

{/* axm-docs:explanatory:start */}

```css
.text-subtle {
  /* Calculate lightness based on the CURRENT context */
  --lightness: calc(
    var(--context-base-lightness) + (0.2 * var(--context-contrast-direction))
  );

  color: oklch(var(--lightness) 0 0);
}
```

{/* axm-docs:explanatory:end */}

## Why This Matters

1.  **Inversion is Free**: To create a "Dark Mode" section inside Light Mode, we just flip the `Context` variables. All children (`.text-subtle`, `.border-muted`) automatically recalculate.
2.  **Infinite Nesting**: You can nest cards inside cards inside sidebars. The contrast ratios are preserved mathematically.
3.  **Component Portability**: A component doesn't need to know if it's on a dark background or a light one. It just asks for "Subtle Text", and the pipeline delivers the correct accessible color.

## The "Weirdness" Budget

This approach requires a mental shift. You stop thinking about "What color is this?" and start thinking "What is the relationship between this element and its container?".

It feels "weird" because CSS has historically been static. But just as React made UI reactive, Axiomatic makes Color reactive. The result is a system that is robust, maintainable, and mathematically accessible by default.

---

## advanced/solver-internals.md

The **Solver** is the engine that powers the color system. It takes your high-level **Intent** and turns it into precise **CSS Tokens**.

You can interact with the Theme Studio in two ways:

1.  **The UI**: The interactive web interface (for exploration).
2.  **The CLI**: The `axiomatic` command line tool (for production).

Both use the exact same "Solver" logic under the hood.

## The "Theme Studio" Model

To understand the solver, it helps to think about the controls you see in the Theme Studio UI. The solver is simply the code that runs every time you move a slider or add a surface.

### 1. Anchors: Defining the Playing Field

In the Theme Studio, you set the **Anchors**. These are the boundaries of your color system.

<div class="not-content">
<div class="surface-workspace docs-p-4 docs-rounded bordered">
<div class="docs-mb-4">
<h4 class="text-strong docs-mb-2">Page Anchors</h4>
<p class="docs-text-subtle-sm">
Defines the lightness range for the "Page" polarity.
</p>
</div>

<!-- Start Slider -->
<div class="docs-mb-4">
<div class="docs-flex-between docs-mb-2">
<span class="text-subtle">Start (Background)</span>
<span class="text-strong">0.98</span>
</div>
<div class="docs-slider-track">
<div class="docs-slider-fill" style="left: 0; width: 98%;"></div>
<div class="docs-slider-thumb right" style="right: 2%;"></div>
</div>
</div>

<!-- End Slider -->
<div>
<div class="docs-flex-between docs-mb-2">
<span class="text-subtle">End (Elevated)</span>
<span class="text-strong">0.12</span>
</div>
<div class="docs-slider-track">
<div class="docs-slider-fill" style="left: 0; width: 12%;"></div>
<div class="docs-slider-thumb left" style="left: 12%;"></div>
</div>
</div>
</div>
</div>

The solver takes these values and asks: **"Can I fit readable text inside this range?"**
If the answer is "No" (and the anchor is adjustable), the solver **moves the slider for you** until the text is readable.

### 2. Surfaces: The "Steps"

In the Theme Studio, you add **Surfaces** to a list.

<div class="not-content">
<div class="surface-workspace docs-p-4 docs-rounded bordered">
<h4 class="text-strong docs-mb-4">Surfaces</h4>

<div class="docs-col">
<!-- Surface Item 1 -->
<div class="surface-card docs-p-2 docs-rounded bordered docs-flex-center-gap">
<span class="text-strong docs-flex-1">Page</span>
<code class="text-subtle">.surface-page</code>
<span class="docs-badge-pass">Passes</span>
</div>

<!-- Surface Item 2 -->
<div class="surface-card docs-p-2 docs-rounded bordered docs-flex-center-gap">
<span class="text-strong docs-flex-1">Card</span>
<code class="text-subtle">.surface-card</code>
<span class="docs-badge-pass">Passes</span>
</div>

<!-- Surface Item 3 -->
<div class="surface-card docs-p-2 docs-rounded bordered docs-flex-center-gap">
<span class="text-strong docs-flex-1">Sidebar</span>
<code class="text-subtle">.surface-sidebar</code>
<span class="docs-badge-pass">Passes</span>
</div>

</div>
</div>
</div>

The solver's job is to place these surfaces evenly between your Start and End anchors.
It doesn't just divide the lightness evenly (e.g., 10%, 20%, 30%). It divides the **Contrast Space** evenly. This ensures that the visual "step" from Page to Card looks the same as the step from Card to Sidebar.

#### Why Contrast Space?

If we just divided the lightness values evenly (Linear Lightness), the steps would look uneven to the human eye. Dark colors bunch up, and light colors spread out. By dividing by **Contrast** (Linear Perception), every step feels visually consistent.

<div class="not-content">
<div class="docs-grid">

<!-- Linear Lightness -->
<div class="surface-workspace docs-p-4 docs-rounded bordered">
<h4 class="text-strong docs-mb-4">Linear Lightness (Bad)</h4>
<div class="docs-col-gap-0">
<div class="docs-p-2 docs-step-95">Step 1 (95%)</div>
<div class="docs-p-2 docs-step-85">Step 2 (85%)</div>
<div class="docs-p-2 docs-step-75">Step 3 (75%)</div>
<div class="docs-p-2 docs-step-65">Step 4 (65%)</div>
<div class="docs-p-2 docs-step-55">Step 5 (55%)</div>
</div>
</div>

<!-- Linear Contrast -->
<div class="surface-workspace docs-p-4 docs-rounded bordered">
<h4 class="text-strong docs-mb-4">Linear Contrast (Good)</h4>
<div class="docs-col-gap-0">
<div class="surface-page docs-p-2">Page (Start)</div>
<div class="surface-workspace docs-p-2">Workspace</div>
<div class="surface-card docs-p-2">Card</div>
<div class="surface-action docs-p-2">Action (End)</div>
</div>
</div>

</div>
</div>

### 3. The Result: Generated Tokens

Finally, the solver outputs the CSS tokens that the Theme Studio (and your app) uses.

<div class="not-content">
<div class="surface-workspace docs-p-4 docs-rounded bordered">
<h4 class="text-strong docs-mb-4">Generated CSS</h4>
<pre class="docs-code-block surface-workspace bordered"><code>--lightness-surface-page: light-dark(0.98, 0.12);
--lightness-surface-card: light-dark(0.95, 0.15);
--lightness-surface-sidebar: light-dark(0.92, 0.18);</code></pre>
</div>
</div>

## The Pipeline

When you run `axiomatic` (for example via `pnpm exec axiomatic`, or best-effort `npx axiomatic`), or change a setting in the Studio, this pipeline executes:

1.  **Hydrate**: Read your `color-config.json`.
2.  **Adjust Anchors**: Ensure the range supports High Contrast text.
3.  **Distribute**: Calculate the target contrast for each surface based on the available range and any `gapBefore` settings.
4.  **Solve Lightness**: Use binary search to find the exact lightness value that hits that contrast target.
5.  **Solve Text**: Find the text colors that sit accessibly on top of those surfaces (APCA-compliant).
6.  **Generate**: Write the CSS tokens.

### High Contrast Generation

The solver runs a second pass to generate a **High Contrast** variant (`@media (prefers-contrast: more)`).
In this pass:

- **Key Colors** are removed (forced to grayscale).
- **Anchors** are pushed to pure Black (0) and White (1).
- **Chroma** is disabled.

This ensures that users who need maximum legibility get a strictly accessible, high-contrast version of your theme automatically.

---

## alpha-limitations.mdx

Axiomatic Color is currently in **alpha**. This means the core engine is stable and production-ready, but some ecosystem features are still in development. This page documents what works, what doesn't, and what's coming next.

## Known Limitations

### Container Query Support

The Inspector currently produces false positives and false negatives when analyzing styles inside `@container` query blocks. This is a known issue tracked for the **beta release**.

**Workaround**: Test container query scenarios manually or use browser DevTools to verify contrast ratios.

### VS Code Extension

A VS Code extension exists in the repository (`packages/vscode-extension/`) but provides no functionality yet.

**Status**: Community contributions welcome, or planned for post-beta depending on demand.

### ESLint Plugin

The ESLint plugin (`packages/eslint-plugin/`) currently contains only one rule (`no-browser-dialogs`) for internal use. More rules for enforcing Axiomatic patterns are planned but not yet implemented.

**Future**: Will include rules like `no-engine-internals`, `no-bridge-transitions`, and `require-surface-nesting`.

### Migration Guides

There are currently no migration guides for upgrading between alpha versions. We'll add these based on alpha feedback once we identify common breaking change patterns.

## What Works Well

These features are **stable** and ready for production use:

### Core Engine

- **Physics solver**: Deterministic, mathematically sound anchor calculation
- **Reactive pipeline**: CSS-only theme transitions with zero JavaScript overhead
- **Context propagation**: Automatic polarity/mode inheritance through surface nesting
- **Hue shifting**: Smooth chromatic adaptation for brand colors

### ThemeManager Integration

- **Runtime theme switching**: Instant, flicker-free transitions between themes
- **State persistence**: localStorage integration with SSR-safe hydration
- **Framework adapters**: React, Svelte, Ember, and vanilla HTML support

### Bridge API for Adapters

- **22 stable exports**: Semantic foreground, border, and accent variables
- **Contract enforcement**: Test-time validation for chrome compliance (Starlight example included)
- **Pay-as-you-go loading**: Adapters only load the bridge CSS they need

### Inspector Diagnostics

- **Contrast violation detection**: Flags WCAG failures with precise diagnosis
- **Provenance tracking**: Shows which CSS variables contributed to a computed color
- **Visual debugging**: Highlights affected elements in the page
- **Exception**: Container query support (see above)

### CLI Solver

- **Theme generation**: Generates consistent, accessible palettes from minimal input
- **Export formats**: Supports CSS, TypeScript, and DTCG (Design Tokens)
- **Config validation**: Schema-backed validation with helpful error messages

## Reporting Issues

**Before filing an issue**, check the [Troubleshooting guide](/reference/troubleshooting) for common solutions.

If you encounter a bug, have a feature request, or need clarification on intended behavior:

- **File an issue**: [GitHub Issues](https://github.com/design-axioms/color/issues)
- **Provide context**: Include your `color-config.json` and reproduction steps
- **Check existing issues**: We may already be tracking it

**Alpha feedback is critical to shaping the beta release.** We're especially interested in:

- Use cases we didn't anticipate
- Integration challenges with specific frameworks
- Documentation gaps or confusing explanations

---

## catalog/actions.mdx

Actions are surfaces that invite user interaction. They are the "buttons" and "controls" of your interface.

## Action Surfaces

### `surface-action`

The primary interactive surface. Used for buttons, toggles, and active states.

<Diagram class="surface-card docs-p-4 docs-rounded docs-flex">
  <button class="surface-action docs-p-2 docs-rounded">Default Action</button>
  <button class="surface-action hue-brand docs-p-2 docs-rounded">
    Brand Action
  </button>
  <button class="surface-action hue-danger docs-p-2 docs-rounded">
    Danger Action
  </button>
</Diagram>

### `surface-action-soft`

A lower-emphasis interactive surface. Useful for secondary buttons or ghost buttons.

<Diagram class="surface-card docs-p-4 docs-rounded docs-flex">
  <button class="surface-action-soft docs-p-2 docs-rounded">Soft Action</button>
  <button class="surface-action-soft hue-brand docs-p-2 docs-rounded">
    Brand Soft
  </button>
</Diagram>

## States

Interactive elements have standard states that work across all surfaces.

### Hover & Active

The system automatically generates hover and active states for all action surfaces.

### `state-selected`

Used to indicate that an item is currently chosen (e.g., a selected item in a list). This maps to the system's "Highlight" color.

<Diagram class="surface-card docs-p-4 docs-rounded">
  <div class="surface-action state-selected docs-p-2 docs-rounded">
    Selected Item
  </div>
</Diagram>

### `state-disabled`

Used for non-interactive items. This maps to the system's "GrayText" color and reduces contrast while maintaining legibility.

<Diagram class="surface-card docs-p-4 docs-rounded">
  <button class="surface-action state-disabled docs-p-2 docs-rounded" disabled>
    Disabled Action
  </button>
</Diagram>

## Focus Indicators

Accessible focus indicators are critical for keyboard navigation. The system provides a universal focus ring that adapts to the brand color and ensures contrast.

<Diagram class="surface-card bordered docs-flex-demo">
  <button class="surface-action focus-ring docs-btn">Focus Me</button>
  <input
    class="surface-workspace focus-ring bordered docs-input"
    placeholder="Focus Me"
  />
</Diagram>

### Usage

Apply the `.focus-ring` utility class to interactive elements. It applies styles on `:focus-visible`.

```html
<button class="surface-action focus-ring">Click Me</button>
```

## Internals (token reference)

Interactive elements use internal surface tokens, plus specific tokens for states and focus. Prefer surface roles, state utilities, and class tokens unless you are building custom primitives.

| Token Variable | Description | Usage |
| :------------- | :---------- | :---- |

{/* axm-docs:explanatory:start */}
| `--axm-focus-ring-color` | The universal focus ring color. | `outline-color: var(--axm-focus-ring-color)` |
| `--axm-surface-token` | The background of the action. | `background: var(--axm-surface-token)` |
| `--axm-text-high-token` | The text color of the action. | `color: var(--axm-text-high-token)` |
{/* axm-docs:explanatory:end */}

---

## catalog/data-viz.mdx

<DemoWrapper>

The Color System includes a built-in engine for generating categorical color palettes that harmonize with your theme. These palettes are designed for data visualization (charts, graphs, maps) where you need distinct colors to represent different categories.

## The Problem

Standard color palettes (like "Tableau 10" or "D3 Category 10") are great, but they often clash with your custom theme.

- If your theme is "Soft Pastel", a neon chart looks out of place.
- If your theme is "High Contrast", a subtle chart might be illegible.
- In Dark Mode, standard colors often lose contrast or look muddy.

## The Solution: Harmonized Fixed Hues

Instead of using a fixed set of hex codes, we use a **Harmonized Fixed Hues** strategy:

1.  **Fixed Hues**: We start with a curated list of distinct hues (Red, Orange, Yellow, Green, etc.) to ensure every color is nameable and distinct.
2.  **Solved Lightness**: We **solve** the lightness of each color against your page background to ensure it meets accessibility targets (APCA ~105).
3.  **Shared Chroma**: We apply a consistent chroma (vibrancy) across the palette, which you can tune to match your brand.

<DataVizDemo />

## Usage

The system generates a categorical palette from your `color-config.json`. For most integrations, prefer consuming the exported tokens (e.g. from the TypeScript exporter) rather than reading engine variables directly.

### Internals (CSS variables)

The engine also exposes CSS variables in the format `--axm-chart-N` for advanced interop:

{/* axm-docs:explanatory:start */}

```css
.my-chart {
  color: var(--axm-chart-1); /* First color in the palette */
}

.my-chart-bar:nth-child(2) {
  background-color: var(--axm-chart-2);
}
```

{/* axm-docs:explanatory:end */}

### Configuration

You can customize the palette in your `color-config.json`:

```json
{
  "palette": {
    "targetChroma": 0.12,
    "hues": [25, 45, 85, 125, 150, 190, 250, 280, 320, 360]
  }
}
```

- **targetChroma**: Controls the vibrancy. `0.12` is a safe default. Higher values (e.g., `0.18`) are more vibrant but might be harder to balance in Light Mode.
- **hues**: An array of hue angles (0-360) to use for the palette.

## Accessibility

Because the lightness is **solved** relative to the background:

- In **Light Mode**, the colors will be darker (like text) to stand out against the white page.
- In **Dark Mode**, the colors will automatically flip to be lighter (pastels) to stand out against the dark page.

This ensures your charts are always legible, regardless of the user's theme preference.

</DemoWrapper>

---

## catalog/surfaces.mdx

<DemoWrapper>

Surfaces are the containers that hold your content. They define the background color, border color, and text context for everything inside them.

## The Canvas

These surfaces form the backdrop of your application.

### `surface-page`

The infinite background. This is usually applied to the `<body>` tag.

## The Containers

These surfaces sit _on top_ of the canvas.

### `surface-card`

The primary container for grouped content. It has a distinct background color that separates it from the canvas.

<Diagram class="surface-page docs-p-4 docs-rounded bordered">
  <div class="surface-card docs-p-4 docs-rounded">This is a Card.</div>
</Diagram>

### `surface-tinted`

A subtle grouping mechanism. It usually has a slight tint of the brand color (or another semantic color) to highlight a section without a hard boundary.

<Diagram class="surface-card docs-p-4 docs-rounded">
  <div class="surface-tinted docs-p-4 docs-rounded">
    This is a Tinted surface inside a Card.
  </div>
</Diagram>

## The Spotlights

These surfaces demand attention. They often use **Inverted Polarity** (Dark on Light, or Light on Dark) to stand out.

### `surface-spotlight`

High contrast. Used for tooltips, toasts, and primary call-to-actions.

<Diagram class="surface-page docs-p-4 docs-rounded bordered">
  <div class="surface-spotlight docs-p-4 docs-rounded">
    This is a Spotlight.
  </div>
</Diagram>

### `surface-soft-spotlight`

A softer version of the spotlight. Useful for badges or indicators that need to be distinct but not shouting.

<Diagram class="surface-page docs-p-4 docs-rounded bordered">
  <div class="surface-soft-spotlight docs-p-4 docs-rounded">
    This is a Soft Spotlight.
  </div>
</Diagram>

## Elevation (Shadows)

Shadows provide depth and hierarchy. The system generates a semantic scale of shadows that are subtle in Light Mode and stronger in Dark Mode to ensure visibility.

<Diagram class="surface-card bordered docs-shadow-grid">
  <div class="surface-card shadow-sm bordered docs-shadow-box">shadow-sm</div>
  <div class="surface-card shadow-md bordered docs-shadow-box">shadow-md</div>
  <div class="surface-card shadow-lg bordered docs-shadow-box">shadow-lg</div>
  <div class="surface-card shadow-xl bordered docs-shadow-box">shadow-xl</div>
</Diagram>

## Internals (token reference)

Every surface exposes internal CSS variables (tokens) that adapt to the surface's background. Prefer surface roles and class tokens unless you are building custom primitives.

| Token Variable | Description | Usage |
| :------------- | :---------- | :---- |

{/* axm-docs:explanatory:start */}
| `--axm-surface-token` | The background color of the surface. | `background: var(--axm-surface-token)` |
| `--axm-text-high-token` | High contrast text color. | `color: var(--axm-text-high-token)` |
| `--axm-text-subtle-token` | Medium contrast text color. | `color: var(--axm-text-subtle-token)` |
| `--axm-text-subtlest-token` | Low contrast text color. | `color: var(--axm-text-subtlest-token)` |
| `--axm-border-dec-token` | Decorative border color (low contrast). | `border-color: var(--axm-border-dec-token)` |
| `--axm-border-int-token` | Interactive border color (higher contrast). | `border-color: var(--axm-border-int-token)` |
{/* axm-docs:explanatory:end */}

</DemoWrapper>

---

## catalog/typography.mdx

In the Axiomatic Color, you don't pick text colors. You pick **Text Hierarchy**.

The system automatically calculates the correct color for each level of hierarchy based on the surface it sits on, ensuring APCA compliance.

## Text Hierarchy

The system provides four levels of text hierarchy, plus a link style.

| Class           | Role        | Usage                                                |
| :-------------- | :---------- | :--------------------------------------------------- |
| `text-strong`   | Headings    | Headings, titles, critical data. Highest contrast.   |
| `text-body`     | Body        | Paragraphs, long-form text. Comfortable for reading. |
| `text-subtle`   | Metadata    | Helper text, timestamps, secondary info.             |
| `text-subtlest` | Disabled    | Placeholders, disabled states. Low emphasis.         |
| `text-link`     | Interactive | Hyperlinks and clickable text elements.              |

<Diagram class="surface-card docs-p-4 docs-rounded docs-col">
  <div class="docs-col-gap-0">
    <h3 class="text-strong text-xl font-bold">The Quick Brown Fox</h3>
    <p class="text-body">The quick brown fox jumps over the lazy dog. This is a sample of body text that is easy to read.</p>
    <div class="docs-flex-between docs-mt-4">
      <span class="text-subtle text-sm">Posted 2 hours ago</span>
      <a href="#" class="text-link text-sm">Read more -></a>
    </div>
  </div>
</Diagram>

## Context Adaptation

The power of these classes is that they adapt to their container.

<Diagram class="docs-grid">
  <div class="surface-card docs-p-4 docs-rounded">
    <strong>Light Context</strong>
    <div class="text-strong">Strong</div>
    <div class="text-body">Body</div>
    <div class="text-subtle">Subtle</div>
  </div>
  <div class="surface-spotlight docs-p-4 docs-rounded">
    <strong>Dark Context</strong>
    <div class="text-strong">Strong</div>
    <div class="text-body">Body</div>
    <div class="text-subtle">Subtle</div>
  </div>
</Diagram>

Notice how `text-strong` is dark on the card but light on the spotlight. You didn't have to change the class name.

---

## concepts/accessibility-first.mdx

In most design systems, accessibility is a step you take _after_ you choose your colors. You pick a palette, check the contrast ratios, and then tweak them until they pass.

In the Axiomatic Color, accessibility is the **input**, not the output.

## The Solver is an Accessibility Engine

When you configure the system, you don't say "I want this specific shade of gray for my text."

You say: **"I want my text to be readable."**

The solver takes that intent and calculates the exact lightness value needed to achieve it. If it's mathematically impossible to achieve that contrast with your current background color, the solver will warn you or adjust the background to make it work.

### APCA: The Future of Contrast

We use the **Advanced Perceptual Contrast Algorithm (APCA)**, the candidate method for WCAG 3.0.

Old contrast ratios (like 4.5:1) are simple math, but they don't match how human eyes work. They often fail to predict readability in Dark Mode.

APCA models **human perception**. It understands that:

1.  **Polarity Matters**: White text on black looks different than black text on white.
2.  **Weight Matters**: Thinner fonts need more contrast than bold fonts.
3.  **Context Matters**: The surrounding light affects how you see a specific element.

By using APCA, the system ensures your text is _actually_ readable, not just technically compliant.

### Mapping APCA to WCAG 2.1

While APCA is the future, we understand that many teams are legally required to meet WCAG 2.1 standards (AA or AAA).




The Axiomatic Color targets APCA values that **exceed** standard WCAG requirements. Here is a rough equivalence guide for compliance auditing:

<Diagram>
  <TokenLevelVisualizer />
</Diagram>

> **Note:** Because APCA is context-aware, these mappings are approximations. However, our baseline target of $L^c 75$ for even the subtlest text ensures that you are safely within the "accessible" range for almost all use cases.

## Automated High Contrast

Some users need more than just "good" contrast. They need **High Contrast**.

Usually, supporting this requires a separate "High Contrast Theme" that you have to maintain manually.

The Axiomatic Color generates this for you automatically. When you build your theme, it creates a `@media (prefers-contrast: more)` block that:

1.  **Maximizes Range**: Pushes the Page background to pure Black/White.
2.  **Increases Contrast**: Bumps up the target contrast ratios for all text.
3.  **Reduces Noise**: Desaturates colors to reduce visual vibration.

The browser applies this automatically based on the user's OS settings.

## Forced Colors (Windows High Contrast)

For users with severe visual impairments who use "Forced Colors Mode" (like on Windows), the system maps your semantic surfaces to system colors.

| Surface          | Maps To      |
| :--------------- | :----------- |
| `surface-card`   | `Canvas`     |
| `text-strong`    | `CanvasText` |
| `surface-action` | `ButtonFace` |
| `text-link`      | `LinkText`   |
| `state-selected` | `Highlight`  |

This ensures that your app behaves like a native application for users who rely on these tools.

## Print is an Accessibility Feature

We treat "Print" as just another mode.

When a user prints your page, the system:

1.  **Forces Light Mode**: To save ink and ensure legibility on paper.
2.  **Removes Backgrounds**: Sets backgrounds to `white` (paper color).
3.  **Adds Borders**: Since backgrounds are gone, it adds borders to `surface-card` and other containers so the structure remains visible.

You don't need to write a print stylesheet. The system's "Physics" just adapt to the medium of "Ink on Paper."

---

## concepts/physics-of-light.mdx

<DemoWrapper>

If "Surfaces" are the atoms of the system, **Physics** is the law that governs them.

Axiomatic Color doesn't store a list of colors for every surface. Instead, it calculates them dynamically based on the environment.

## 1. Solar Time

Instead of a binary "Light Mode" vs "Dark Mode" switch, the system models time as a continuous cycle.

- **Noon**: Bright Day (Light Mode).
- **Midnight**: Deep Night (Dark Mode).
- **Twilight**: The transition zone.

Every surface in the system knows what "Time" it is. When you switch modes, you aren't swapping a stylesheet; you are moving the sun.

## 2. The Taper (Spatial Safety)

In the real world, you can't have a "Neon Black" or a "Neon White". As colors get very dark or very light, they lose their ability to hold saturation.

The system enforces this with **The Taper**.

Imagine a cone (or a "Bicone") in the color space.

- At 50% Gray, you can have maximum vibrancy.
- As you approach Black (0%) or White (100%), the available vibrancy tapers off to zero.

This ensures that no matter how you configure your theme, you never accidentally create a color that is "out of gamut" (impossible to display) or that vibrates uncomfortably against the text.

## 3. The Tunnel (Temporal Safety)

The most dangerous time for color design is **Twilight**. This is the moment when the background is 50% gray.

If we just linearly interpolated colors from Day to Night, the middle point would often be a muddy, low-contrast mess.

To prevent this, the system uses a **Tunneling** effect. As the system transitions through Twilight, it automatically dampens the vibrancy of all surfaces. It creates a "Diving Bell" of safety, ensuring that text remains legible even during the animation between modes.

## Why is this better?

In a traditional system (Hex codes), changing the background color breaks everything.

- "I made the background darker, now the cards are invisible."
- "I made the background lighter, now the text contrast is failing."

In the Axiomatic System, the solver **re-runs the physics simulation** every time the environment changes. It guarantees that:

1.  **Legibility**: Text is always readable, because the Taper prevents the background from eating the contrast.
2.  **Gamut Safety**: You can't pick an "illegal" color. The math won't let you.
3.  **Smooth Transitions**: Switching modes is a fluid, mathematical operation, not a jarring jump cut.

</DemoWrapper>

---

## concepts/thinking-in-surfaces.mdx

<DemoWrapper>

**Static palettes are not enough for modern interfaces.**

In a dynamic UI, colors change based on where they live. A "gray" text needs to be dark on a white card, but light on a dark tooltip.

Axiomatic Color acts as a **Context Engine**. Instead of giving you a fixed list of colors, it gives you **Surfaces** that automatically adjust their content to fit the environment.

## The Core Concept

A **Surface** is not just a background color. It **sets the rules** for everything inside it.

When you place an element on a surface, you aren't just painting pixels. You are entering a new **Context**.

### 1. Surfaces Create Context

Every surface acts as a "Context Provider." It automatically sets a suite of CSS variables that determine how text, borders, and other elements should look _when sitting on that specific surface_.

<Diagram>
  <div class="mb-4 text-sm text-subtle">
    <span>Use the global Token Inspector{" "}</span>
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="16"
      height="16"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
      style="display: inline-block; vertical-align: middle; margin: 0 2px;"
    >
      <path d="M3 7V5a2 2 0 0 1 2-2h2" />
      <path d="M17 3h2a2 2 0 0 1 2 2v2" />
      <path d="M21 17v2a2 2 0 0 1-2 2h-2" />
      <path d="M7 21H5a2 2 0 0 1-2-2v-2" />
      <circle cx="12" cy="12" r="3" />
      <path d="m16 16-1.9-1.9" />
    </svg>
    <span>{" "}to inspect these surfaces.</span>
  </div>
  <ContextVisualizer />
</Diagram>

In the visualization above:

1.  The **Page** sets the baseline context (Light Mode).
2.  The **Card** sits on the Page. It might be slightly lighter or darker, but it maintains the same **Solar Time** (Light text on Dark, or Dark text on Light).
3.  The **Spotlight** (the dark box) _inverts_ the time. It tells its children: "I am dark. You must be light."

### 2. Content Adapts to Context

Because of this architecture, your components become **portable**.

You don't write CSS like `.card .text` or `.footer .text`. You just write `.text-strong`.

- If `.text-strong` is on a white card, it resolves to black.
- If `.text-strong` is on a black tooltip, it resolves to white.

The component doesn't know where it is. The _Surface_ tells it how to render.

## The Hierarchy of Surfaces

We categorize surfaces based on their physical role in the UI, not their color.

### The Canvas

These are the foundations. They recede into the background.

<div class="docs-grid not-content my-6">
  <SurfacePreview
    surface="surface-page"
    name="Page"
    description="The infinite backdrop."
  >
    <div
      class="bordered"
      style="margin-top: 1rem; height: 6rem; border-style: dashed; border-radius: 0.5rem; display: flex; align-items: center; justify-content: center; font-size: 0.875rem;"
    >
      <span class="text-subtle">Application Root</span>
    </div>
  </SurfacePreview>
  <SurfacePreview
    surface="surface-workspace"
    name="Workspace"
    description="A dedicated area for tools or navigation."
  >
    <div style="margin-top: 1rem; display: flex; gap: 0.5rem; height: 6rem;">
      <div
        class="surface-card bordered"
        style="width: 33%; height: 100%; border-radius: 0.25rem;"
      ></div>
      <div
        class="surface-card bordered"
        style="width: 66%; height: 100%; border-radius: 0.25rem;"
      ></div>
    </div>
  </SurfacePreview>
</div>

### The Objects

These sit _on top_ of the canvas. They hold your content.

<div class="docs-grid not-content my-6">
  <SurfacePreview
    surface="surface-card"
    name="Card"
    description="The primary container for information."
  >
    <div style="margin-top: 1rem; display: flex; flex-direction: column; gap: 0.75rem;">
      <div
        class="text-subtle"
        style="height: 0.5rem; width: 33%; box-shadow: inset 0 0 0 9999px currentColor; opacity: 0.2; border-radius: 0.125rem;"
      ></div>
      <div
        class="text-subtle"
        style="height: 0.5rem; width: 75%; box-shadow: inset 0 0 0 9999px currentColor; opacity: 0.2; border-radius: 0.125rem;"
      ></div>
      <div
        class="text-subtle"
        style="height: 0.5rem; width: 50%; box-shadow: inset 0 0 0 9999px currentColor; opacity: 0.2; border-radius: 0.125rem;"
      ></div>
    </div>
  </SurfacePreview>
  <SurfacePreview
    surface="surface-card"
    tint="hue-brand"
    name="Tinted"
    description="A subtle grouping mechanism."
  >
    <div style="margin-top: 1rem; display: flex; flex-direction: column; gap: 0.75rem;">
      <div
        class="text-brand"
        style="height: 0.5rem; width: 33%; box-shadow: inset 0 0 0 9999px currentColor; opacity: 0.4; border-radius: 0.125rem;"
      ></div>
      <div
        class="text-brand"
        style="height: 0.5rem; width: 75%; box-shadow: inset 0 0 0 9999px currentColor; opacity: 0.3; border-radius: 0.125rem;"
      ></div>
    </div>
  </SurfacePreview>
</div>

### The Interactors

These are actionable. They invite touch.

<div class="docs-grid not-content my-6">
  <SurfacePreview
    surface="surface-card"
    name="Action"
    description="Buttons, toggles, and controls."
  >
    <button
      class="surface-action text-strong"
      style="margin-top: 1rem; display: flex; align-items: center; justify-content: center; height: 3rem; width: 100%; border-radius: 0.25rem; font-weight: bold; font-size: 0.875rem; border: none; cursor: pointer;"
    >
      Click Me
    </button>
  </SurfacePreview>
  <SurfacePreview
    surface="surface-card"
    name="Soft Action"
    description="Secondary interactive elements."
  >
    <button
      class="surface-action-soft bordered"
      style="margin-top: 1rem; display: flex; align-items: center; justify-content: center; height: 3rem; width: 100%; border-radius: 0.25rem; font-weight: 500; font-size: 0.875rem; cursor: pointer;"
    >
      Cancel
    </button>
  </SurfacePreview>
</div>

### The Spotlights

These demand attention. They often break the current polarity to stand out.

<div class="docs-grid not-content my-6">
  <SurfacePreview
    surface="surface-spotlight"
    name="Spotlight"
    description="Tooltips, toasts, and primary calls-to-action."
  >
    <div style="margin-top: 1rem; display: flex; align-items: center; gap: 0.75rem;">
      <div
        class="surface-status-success"
        style="width: 0.5rem; height: 0.5rem; border-radius: 9999px;"
      ></div>
      <span style="font-size: 0.875rem; font-weight: 500;">
        Changes saved successfully
      </span>
    </div>
  </SurfacePreview>
</div>

**Note on Inversion**: Spotlight surfaces perform a "Hard Flip" of the theme. If your app is in Light Mode, a Spotlight surface forces its internals into Dark Mode (and vice versa). This ensures that native browser controls (like scrollbars and checkboxes) render correctly inside the inverted area.

## X-Ray Mode (Forced Colors)

What happens when the user turns on "High Contrast Mode" in Windows?

In this mode, the operating system strips away all background colors to ensure maximum legibility. This can be disastrous for modern UIs that rely on background colors to define structure (like a white card on a gray background).

Axiomatic Color handles this with **X-Ray Mode**.

When the system detects `forced-colors: active`, it automatically switches from "Rich Mode" (painting pixels) to "X-Ray Mode" (drawing outlines).

- **Rich Mode**: A card has a white background and no border.
- **X-Ray Mode**: The background becomes transparent, and a **Border** appears automatically.

This ensures that your UI structure remains visible ("Fail Visible") even when the user strips away the paint.

## Why This Matters

By thinking in surfaces, you stop fighting with contrast ratios.

1.  **Guaranteed Contrast**: The system calculates the foreground colors based on the background surface. If the surface changes, the text changes.
2.  **Automatic Dark Mode**: You don't design "Dark Mode" separately. You just define your surfaces, and the system flips the context.
3.  **Infinite Nesting**: You can put a Card inside a Sidebar inside a Page. The system handles the math to ensure distinctness at every level.

</DemoWrapper>

---

## guides/configuration.mdx

The `color-config.json` file is the heart of your design system. It defines your semantic intent, and the solver uses it to generate your CSS.

## Structure

The configuration is divided into three main sections:

1.  **Vibes**: High-level presets that control the "physics" of the system.
2.  **Anchors**: The fixed points of lightness that define your contrast range.
3.  **Groups & Surfaces**: The semantic taxonomy of your UI.

```json
{
  "$schema": "node_modules/@axiomatic-design/color/color-config.schema.json",
  "vibes": {
    "mode": "default"
  },
  "anchors": { ... },
  "groups": [ ... ]
}
```

## Vibes (Presets)

Vibes are the easiest way to change the look and feel of your system without tweaking individual math parameters. They configure the underlying physics engine (hue shifting, chroma scaling, and contrast targets).

### Usage

Add a `vibes` object to your config:

```json
{
  "vibes": {
    "mode": "vibrant"
  }
}
```

## Customizing Colors

To set your own brand colors, define them in the `anchors` section. This overrides the default hue for the system.

```json
{
  "anchors": {
    "brand": "#RRGGBB"
  }
}
```

## Available Vibes

| Vibe          | Description                          | Characteristics                                  |
| :------------ | :----------------------------------- | :----------------------------------------------- |
| **default**   | Balanced and neutral.                | Standard contrast, minimal hue shift.            |
| **vibrant**   | High energy and saturation.          | Aggressive hue shifting, higher chroma surfaces. |
| **corporate** | Safe, blue-tinted, and professional. | Cool grays, high contrast text, conservative.    |
| **academic**  | Low chroma, high legibility.         | Warm grays, serif-friendly, paper-like.          |

## Anchors

Anchors define the "Lightness Space" of your application. They tell the solver where "White" and "Black" are, and how much contrast is required for text.

See [Physics of Light](/concepts/physics-of-light) for a deep dive.

## Groups & Surfaces

Surfaces are organized into **Groups** (e.g., "Canvas", "Objects", "Actions"). This is purely for organization and does not affect the output CSS.

See [Thinking in Surfaces](/concepts/thinking-in-surfaces) for the mental model.

---

## guides/ecosystem/figma.mdx

The Axiomatic Color is designed to be the "Source of Truth" for your color palette. However, we know that design happens in tools like Figma. This guide explains how to bridge the gap.

## The Workflow

1.  **Configure & Solve**: Use the [Theme Studio](/guides/theme-builder) or edit `color-config.json` to define your system.
2.  **Export**: Run the CLI to generate a W3C Design Tokens (DTCG) file.
3.  **Import**: Load the tokens into Figma using a plugin like **Tokens Studio**.

:::caution[Code First]
The flow is **unidirectional**. You should treat your `color-config.json` as the source of truth. If you make changes in Figma, they will be lost the next time you import tokens. Always update the config first, then re-export.
:::

## Exporting Tokens

To generate a DTCG-compatible JSON file, use the `export` command:

```bash
pnpm exec axiomatic export --format dtcg --out tokens/
```

Best-effort alternative:

```bash
npx axiomatic export --format dtcg --out tokens/
```

This will output a directory containing your theme tokens split into logical sets:

- `tokens/primitives.json`: Global values like Key Colors.
- `tokens/light.json`: Semantic tokens for Light Mode.
- `tokens/dark.json`: Semantic tokens for Dark Mode.

This "Multi-File" structure is the standard for modern design token tools (like Tokens Studio), allowing you to treat Light and Dark modes as switchable themes.

### Single File Export (Legacy)

If you prefer a single JSON file, you can specify a file path instead of a directory:

```bash
pnpm exec axiomatic export --format dtcg --out tokens.json
```

Best-effort alternative:

```bash
npx axiomatic export --format dtcg --out tokens.json
```

## Importing into Figma

### Using Tokens Studio (Recommended)

[Tokens Studio for Figma](https://tokens.studio/) is the industry standard for managing design tokens in Figma. It fully supports the W3C format.

1.  Open the **Tokens Studio** plugin in Figma.
2.  Go to the **Tools** tab (or Settings).
3.  Click **Load from file/folder** or **Import**.
4.  Select your `tokens/` directory (or the individual JSON files).
5.  The plugin will create token sets for `primitives`, `light`, and `dark`.

**Best Practice**:

- Enable the **primitives** set as "Source" (Reference only).
- Enable **light** OR **dark** as "Active" to switch themes.

### Using Native Figma Variables

Native Figma Variables are powerful but have a stricter structure. Currently, the best way to import DTCG tokens into native variables is via a plugin that handles the conversion, or by using Tokens Studio's "Create Variables" feature.

1.  Import tokens into **Tokens Studio** (as above).
2.  Click **Create Variables** in the plugin.
3.  Map the `light` and `dark` sets to a Figma Mode (e.g., "Color Mode").

## Token Structure

The exported tokens follow this structure:

- **Surfaces**: `light.surface.brand`, `dark.surface.brand`
- **Foregrounds**: `light.on-surface.brand.high`, `dark.on-surface.brand.high`

This structure ensures that you can bind your Figma layers to semantic tokens (like "Brand Surface") rather than raw hex values.

---

## guides/example.md

Guides lead a user through a specific task they want to accomplish, often with a sequence of steps.
Writing a good guide requires thinking about what your users are trying to do.

## Further reading

- Read [about how-to guides](https://diataxis.fr/how-to-guides/) in the Diátaxis framework

---

## guides/frameworks/custom.mdx

If we don't have a guide for your specific framework, don't worry! The Axiomatic Color system is designed to be framework-agnostic. This guide covers the core concepts and APIs you need to build your own integration.

## Core Concepts

There are three main pieces you need to implement:

1.  **Theme Management**: Handling light/dark mode and system preferences.
2.  **Surfaces**: A component to apply surface styles and nest contexts.
3.  **Tokens**: Accessing the design tokens in your components.

## 1. Theme Management

The library provides a `ThemeManager` class that handles the complexity of:

- Detecting system color preferences.
- Listening for changes (e.g., when the user changes their OS theme).
- Syncing the `meta[name="theme-color"]` tag.
- Publishing semantic state (`data-axm-mode`, `data-axm-resolved-mode`) on the root element.

### The `ThemeManager` Class

```typescript


// 1. Initialize
const manager = new ThemeManager();

// 2. Get current state
console.log(manager.mode); // 'light' | 'dark' | 'system'
console.log(manager.resolvedMode); // 'light' | 'dark' (resolves 'system')

// 3. Change mode
manager.setMode("dark");

// 4. Cleanup (if needed)
manager.dispose();
```

### Implementing a Store/Context

Most frameworks have a way to share state (Context in React, Stores in Svelte, Services in Ember). You should wrap the `ThemeManager` in your framework's state management primitive.

**Requirements for your wrapper:**

1.  **Persistence**: The `ThemeManager` does _not_ handle `localStorage`. You should read/write to `localStorage` in your wrapper.
2.  **Reactivity**: The `ThemeManager` is imperative. You need to expose its state (`mode` and `resolvedMode`) in a reactive way for your UI to update.

## 2. The Surface Component

The "Surface" is the fundamental building block. It does two things:

1.  Sets the `background-color` and `color` for its container.
2.  Establishes a new "context" for nested content (e.g., adjusting contrast).

Your framework likely has a way to render a component with a dynamic class.

```typescript


// Pseudo-code for a Surface component
function Surface({ variant, as = "div", children }) {
  // 1. Get the class name for the variant (e.g., "surface-card")
  const className = tokens.surface[variant];

  // 2. Render the element
  return <as className={className}>{children}</as>;
}
```

## 3. Accessing Tokens

When you run `axiomatic export`, you generate a TypeScript file containing your tokens.

```bash
npx axiomatic export --format typescript --out src/theme.ts
```

This file exports a `tokens` object that mirrors your CSS variables.

```typescript


// Usage in styles
const style = {
  color: tokens.context.text.high,
};
```

### Why use the JS tokens?

You _can_ use the CSS variables directly (e.g., `var(--text-high)`), but the JS tokens provide:

- **Type Safety**: TypeScript will error if you use a token that doesn't exist.
- **Refactoring**: Renaming a token in your config will cause build errors where it's used.
- **Autocomplete**: Your IDE will suggest available tokens.

## Checklist

To have a complete integration, ensure you have:

- [ ] Generated `theme.css` and imported it globally.
- [ ] Generated `theme.ts` for type-safe token access.
- [ ] Created a `ThemeService` / `ThemeContext` wrapping `ThemeManager`.
- [ ] Created a `<Surface>` component.
- [ ] (Optional) Added a theme toggle UI.

---

## guides/frameworks/ember.mdx

This guide shows you how to integrate the Axiomatic Color into a modern Polaris Ember application (using `.gts` components and Vite).

## 1. Setup

First, install the CLI and generate your theme CSS and TypeScript definitions.

```bash
pnpm add -D @axiomatic-design/color
pnpm exec axiomatic init
pnpm exec axiomatic build --out ./app/styles/theme.css
pnpm exec axiomatic export --format typescript --out ./app/utils/theme.ts

# Best-effort (if you prefer npm)
npm install -D @axiomatic-design/color
npx axiomatic init
npx axiomatic build --out ./app/styles/theme.css
npx axiomatic export --format typescript --out ./app/utils/theme.ts
```

Import the CSS in your application's entry point (e.g., `app/app.ts` or `app/styles/app.css` if using CSS imports).

```css
/* app/styles/app.css */
@import "./theme.css";
```

## 2. The Surface Helper

We recommend using a simple helper function to apply surface tokens. This keeps your template structure flat and allows you to use standard HTML elements.

```ts
// app/helpers/surface.ts


export function surface(variant: keyof typeof tokens.surface): string {
  return tokens.surface[variant];
}
```

You can then use this helper directly in your `.gts` components:

```gts


<template>
  <div class={{surface "card"}}>
    Content
  </div>
</template>
```

This approach provides full type safety with Glint, ensuring you only use valid surface variants.

## 3. The Theme Service

The library provides a `ThemeManager` class to handle the low-level details of theme switching (like updating `meta` tags and handling system preferences). We can wrap this in an Ember Service to add persistence.

```ts
// app/services/theme.ts




export default class ThemeService extends Service {
  @tracked mode: ThemeMode = "system";
  private manager: ThemeManager;

  constructor() {
    super(...arguments);
    // Initialize the manager
    this.manager = new ThemeManager();

    // Restore saved preference
    this.restore();
  }

  restore() {
    const saved = localStorage.getItem("theme") as ThemeMode | null;
    if (saved) {
      this.setMode(saved);
    }
  }

  setMode(mode: ThemeMode) {
    this.mode = mode;
    this.manager.setMode(mode);
    localStorage.setItem("theme", mode);
  }

  toggle() {
    const next = this.manager.resolvedMode === "light" ? "dark" : "light";
    this.setMode(next);
  }
}
```

## 4. Usage Example

Here is how you put it all together in a component.

```gts
// app/components/welcome.gts








export default class Welcome extends Component {
  @service declare theme: ThemeService;

  <template>
    <div class={{surface "page"}} style="min-height: 100vh; padding: 2rem;">
      <header style="display: flex; justify-content: space-between;">
        <h1 style={{concat "color: " tokens.context.text.high}}>My Ember App</h1>

        <button type="button" {{on "click" this.theme.toggle}}>
          {{#if (eq this.theme.manager.resolvedMode "light")}}
            🌙
          {{else}}
            ☀️
          {{/if}}
        </button>
      </header>

      <main>
        <div class={{surface "card"}} style="padding: 2rem; border-radius: 8px;">
          <h2 style={{concat "color: " tokens.context.text.high}}>Hello World</h2>
          <p style={{concat "color: " tokens.context.text.subtle}}>
            This card is automatically themed based on its context.
          </p>
        </div>
      </main>
    </div>
  </template>
}
```

## 5. Build vs. Runtime

The Axiomatic Color is designed to be flexible.

### Build Time (Recommended)

The `axiomatic build` command generates a static CSS file. This is the most performant option.

```css
/* app/styles/app.css */
@import "./theme.css";
```

### Runtime

You can also use the `runtime` module to generate themes in the browser. This is useful for user-customizable themes.

```ts



// Load your config (e.g. from an API or JSON file)
const config: SolverConfig = { ... };

// Generate and inject the CSS
const css = generateTheme(config);
injectTheme(css);
```

> **Note:** The rest of this guide (the Surface helper, Theme Service, and usage patterns) works exactly the same way regardless of which mode you choose. The only difference is how the CSS variables are generated and loaded.

---

## guides/frameworks/html.mdx

This guide shows you how to integrate the Axiomatic Color into a plain HTML project.

## 1. Setup

First, install the CLI and generate your theme CSS.

```bash
# Recommended
pnpm add -D @axiomatic-design/color
pnpm exec axiomatic init
pnpm exec axiomatic build --out ./public/theme.css

# Best-effort (if you prefer npm)
npm install -D @axiomatic-design/color
npx axiomatic init
npx axiomatic build --out ./public/theme.css
```

Link the CSS in your HTML file:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/@axiomatic-design/color@latest/engine.css"
    />
    <link rel="stylesheet" href="/theme.css" />
    <title>My App</title>
  </head>
  <body>
    <!-- Content goes here -->
  </body>
</html>
```

## 2. Using Surfaces

In HTML, you apply surfaces using the generated utility classes.

```html
<!-- The page surface sets the background for the body -->
<body class="surface-page">
  <main style="padding: 2rem;">
    <!-- A card surface -->
    <div class="surface-card" style="padding: 2rem; border-radius: 8px;">
      <h2 class="text-strong">Hello World</h2>
      <p class="text-subtle">
        This card is automatically themed based on its context.
      </p>
    </div>
  </main>
</body>
```

## 3. The Theme Toggle

To handle Dark Mode, use the library’s `ThemeManager`.

```html
<button id="theme-toggle">Toggle Theme</button>

<script type="module">
  import { ThemeManager } from "https://unpkg.com/@axiomatic-design/color@latest/browser";

  const toggle = document.getElementById("theme-toggle");
  const manager = new ThemeManager();

  // Optional persistence: ThemeManager doesn't own localStorage.
  const saved = localStorage.getItem("theme");
  if (saved === "light" || saved === "dark" || saved === "system") {
    manager.setMode(saved);
  }

  toggle.addEventListener("click", () => {
    const next = manager.resolvedMode === "light" ? "dark" : "light";
    manager.setMode(next);
    localStorage.setItem("theme", next);
  });
</script>
```

---

## guides/frameworks/react.mdx

This guide shows you how to integrate the Axiomatic Color into a React application using TypeScript.

## 1. Setup

First, install the CLI and generate your theme CSS and TypeScript definitions.

```bash
# Recommended
pnpm add -D @axiomatic-design/color
pnpm exec axiomatic init
pnpm exec axiomatic build --out ./src/theme.css
pnpm exec axiomatic export --format typescript --out ./src/theme.ts

# Best-effort (if you prefer npm)
npm install -D @axiomatic-design/color
npx axiomatic init
npx axiomatic build --out ./src/theme.css
npx axiomatic export --format typescript --out ./src/theme.ts
```

Import the CSS in your root entry point (e.g., `main.tsx` or `App.tsx`):

```tsx
import "./theme.css";
```

## 2. The Surface Component

The core concept of the system is the **Surface**. In React, we can create a reusable `<Surface>` component that handles the nesting logic automatically.

```tsx
// src/components/Surface.tsx



type SurfaceProps = {
  as?: React.ElementType;
  variant: keyof typeof tokens.surface;
  children: React.ReactNode;
  className?: string;
} & React.HTMLAttributes<HTMLElement>;

export function Surface({
  as: Component = "div",
  variant,
  children,
  className = "",
  ...props
}: SurfaceProps) {
  const surfaceClass = tokens.surface[variant];

  return (
    <Component className={`${surfaceClass} ${className}`} {...props}>
      {children}
    </Component>
  );
}
```

## 3. The Theme Context

To handle Dark Mode and System preferences robustly, we recommend creating a Context that wraps the `ThemeManager`.

```tsx
// src/context/ThemeContext.tsx



type ThemeContextType = {
  mode: ThemeMode;
  setMode: (mode: ThemeMode) => void;
  toggle: () => void;
};

const ThemeContext = createContext<ThemeContextType | null>(null);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  // Initialize the manager once
  const [manager] = useState(() => new ThemeManager());
  const [mode, setModeState] = useState<ThemeMode>("system");

  useEffect(() => {
    // Restore saved preference on mount
    const saved = localStorage.getItem("theme") as ThemeMode | null;
    if (saved) {
      manager.setMode(saved);
      setModeState(saved);
    }
  }, [manager]);

  const setMode = (newMode: ThemeMode) => {
    manager.setMode(newMode);
    setModeState(newMode);
    localStorage.setItem("theme", newMode);
  };

  const toggle = () => {
    const next = manager.resolvedMode === "light" ? "dark" : "light";
    setMode(next);
  };

  return (
    <ThemeContext.Provider value={{ mode, setMode, toggle }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) throw new Error("useTheme must be used within a ThemeProvider");
  return context;
}
```

## 4. Usage Example

Wrap your application in the `ThemeProvider`, and then use the `useTheme` hook to control the theme.

```tsx
// src/App.tsx




function Header() {
  const { toggle, mode } = useTheme();

  return (
    <header style={{ display: "flex", justifyContent: "space-between" }}>
      <h1 style={{ color: tokens.context.text.high }}>My App</h1>
      <button onClick={toggle}>{mode === "light" ? "🌙" : "☀️"}</button>
    </header>
  );
}

export default function App() {
  return (
    <ThemeProvider>
      <Surface variant="page" style={{ minHeight: "100vh", padding: "2rem" }}>
        <Header />

        <main>
          <Surface
            variant="card"
            style={{ padding: "2rem", borderRadius: "8px" }}
          >
            <h2 style={{ color: tokens.context.text.high }}>Hello World</h2>
            <p style={{ color: tokens.context.text.subtle }}>
              This card is automatically themed based on its context.
            </p>
          </Surface>
        </main>
      </Surface>
    </ThemeProvider>
  );
}
```

---

## guides/frameworks/svelte.mdx

This guide shows you how to integrate the Axiomatic Color into a Svelte application using TypeScript.

## 1. Setup

First, install the CLI and generate your theme CSS and TypeScript definitions.

```bash
# Recommended
pnpm add -D @axiomatic-design/color
pnpm exec axiomatic init
pnpm exec axiomatic build --out ./src/theme.css
pnpm exec axiomatic export --format typescript --out ./src/lib/theme.ts

# Best-effort (if you prefer npm)
npm install -D @axiomatic-design/color
npx axiomatic init
npx axiomatic build --out ./src/theme.css
npx axiomatic export --format typescript --out ./src/lib/theme.ts
```

Import the CSS in your root layout (e.g., `src/routes/+layout.svelte`):

```svelte
<script>
  import "../theme.css";
</script>

<slot />
```

## 2. The Surface Component

We can create a reusable `<Surface>` component.

```svelte
<!-- src/lib/components/Surface.svelte -->
<script lang="ts">
  import { tokens } from "$lib/theme";
  import type { HTMLAttributes } from "svelte/elements";

  interface Props extends HTMLAttributes<HTMLElement> {
    variant: keyof typeof tokens.surface;
    as?: string;
    children?: import("svelte").Snippet;
  }

  let {
    variant,
    as = "div",
    class: className = "",
    children,
    ...rest
  }: Props = $props();

  const surfaceClass = tokens.surface[variant];
</script>

<svelte:element this={as} class="{surfaceClass} {className}" {...rest}>
  {@render children?.()}
</svelte:element>
```

## 3. The Theme Service

We can wrap the `ThemeManager` in a Svelte 5 reactive class to handle state management.

```typescript
// src/lib/theme.svelte.ts


export class ThemeService {
  private manager: ThemeManager;
  mode = $state<ThemeMode>("system");

  constructor() {
    this.manager = new ThemeManager();

    // Restore saved preference
    if (typeof localStorage !== "undefined") {
      const saved = localStorage.getItem("theme") as ThemeMode | null;
      if (saved) {
        this.setMode(saved);
      }
    }
  }

  setMode(mode: ThemeMode) {
    this.mode = mode;
    this.manager.setMode(mode);
    localStorage.setItem("theme", mode);
  }

  toggle() {
    const next = this.manager.resolvedMode === "light" ? "dark" : "light";
    this.setMode(next);
  }
}

// Export a singleton instance
export const theme = new ThemeService();
```

## 4. Usage Example

```svelte
<!-- src/routes/+page.svelte -->
<script lang="ts">
  import Surface from "$lib/components/Surface.svelte";
  import { theme } from "$lib/theme.svelte";
  import { tokens } from "$lib/theme";
</script>

<Surface variant="page" style="min-height: 100vh; padding: 2rem;">
  <header style="display: flex; justify-content: space-between;">
    <h1 style="color: {tokens.context.text.high}">My App</h1>

    <button onclick={() => theme.toggle()}>
      {theme.mode === "light" ? "🌙" : "☀️"}
    </button>
  </header>

  <main>
    <Surface variant="card" style="padding: 2rem; border-radius: 8px;">
      <h2 style="color: {tokens.context.text.high}">Hello World</h2>
      <p style="color: {tokens.context.text.subtle}">
        This card is automatically themed based on its context.
      </p>
    </Surface>
  </main>
</Surface>
```

---

## guides/integration.md

Once you have generated your `theme.css` file, integrating it is straightforward. The system produces standard CSS, so it works with any framework (React, Vue, Svelte, etc.) or vanilla HTML.

> **Working Example**: See the [Vercel Demo](https://github.com/design-axioms/color/tree/main/examples/vercel-demo) for a complete Vite + React integration with runtime solver, theme toggle, and dynamic brand color picker.

## 1. Load the CSS

Import the generated file into your application's entry point.

### Vanilla HTML

```html
<head>
  <link
    rel="stylesheet"
    href="https://unpkg.com/@axiomatic-design/color@latest/engine.css"
  />
  <link rel="stylesheet" href="/styles/theme.css" />
</head>
```

### JavaScript / Bundlers (Vite, Webpack)

```javascript
// main.js or index.tsx
import "@axiomatic-design/color/engine.css";
import "./styles/theme.css";
```

### About `*.class-tokens.json`

When you generate `theme.css`, the CLI also writes a class-token manifest alongside it (for example `theme.class-tokens.json`). This file is used for tooling and enforcement (e.g., lint rules and automated checks). Most applications don’t need to read it directly.

## 2. Set the Root Surface

The system requires a "Root Surface" to establish the initial context. Usually, this is the `<body>` tag.

```html
<body class="surface-page">
  <!-- Your app goes here -->
</body>
```

This sets the background color of the page and initializes the CSS variables for the "Page" context.

## Adapter boundary (Bridge exports)

Sometimes you need to integrate Axiomatic Color into a host system that already “owns” its own palette variables and chrome.

In that situation, the contract is:

For a concrete example mapping, see [Bridge API (Adapters)](/advanced/bridge-api).

Continuity constraints (the “interesting” part):

- Bridge exports must not become a second animation driver.
- Chrome borders must not be coupled to text color (`currentColor`).
- Painted properties in chrome should not introduce independent transitions that compete with the engine’s driver.

For a concrete example mapping, see the advanced Bridge API note.

## 3. Using Surfaces

Now you can start building your UI using the semantic classes.

### The Card Pattern

The most common pattern is placing content inside a card.

```html
<div class="surface-card">
  <h2 class="text-strong">Card Title</h2>
  <p class="text-subtle">Card content goes here.</p>
</div>
```

### The Button Pattern

Buttons are interactive surfaces.

```html
<button class="surface-action hue-brand">Primary Action</button>

<button class="surface-action">Secondary Action</button>
```

## 4. Setting Up ThemeManager

**ThemeManager is required** for most applications. If you need dark mode, theme switching, or inverted surfaces (like cards that flip polarity), this is the answer—and it's simpler than what you were probably doing before.

### What ThemeManager Does For You

- **System preference detection** — Automatically syncs with `prefers-color-scheme`
- **Inverted surfaces** — Coordinates cards, spotlights, and other surfaces that flip between light/dark
- **Browser integration** — Updates `<meta name="theme-color">` and `color-scheme`
- **Native controls** — Ensures scrollbars, inputs, and checkboxes match the theme

You would have to implement all of this yourself. ThemeManager does it in 3 lines of code.

### Basic Setup

```ts



const themeManager = new ThemeManager({ invertedSelectors });
```

**That's it.** Your app now has light/dark mode based on system preference.

### Building a Theme Toggle

```ts



const themeManager = new ThemeManager({ invertedSelectors });

// Toggle button
document.getElementById("theme-toggle")?.addEventListener("click", () => {
  const newMode = themeManager.resolvedMode === "light" ? "dark" : "light";
  themeManager.setMode(newMode);
  localStorage.setItem("theme-mode", newMode);
});

// Restore on load
const savedMode = localStorage.getItem("theme-mode");
if (savedMode === "light" || savedMode === "dark") {
  themeManager.setMode(savedMode);
}
```

### About `invertedSelectors`

The `invertedSelectors` array tells ThemeManager which surfaces flip polarity. Generate it by running:

```bash
axiomatic build --emit-ts
```

This creates `theme.generated.ts` with the selectors for your configured inverted surfaces. **Do not skip the `--emit-ts` flag**—without it, inverted surfaces won't work correctly.

> **Smooth transitions**: `light-dark()` selects endpoints based on context; smoothness comes from transitioning the computed colors. If another framework sets mode-dependent `background-color`/`color` directly (or disables transitions during toggles), you may see "snaps" even though the Axiomatic engine is correct.

## 5. Inverted Surfaces

Some surfaces, like `surface-spotlight`, are defined as "Inverted". This means they automatically flip the theme context.

- In **Light Mode**, a spotlight is **Dark**.
- In **Dark Mode**, a spotlight is **Light**.

The system achieves this using the standard `color-scheme` CSS property. This ensures that native browser controls (like scrollbars and checkboxes) inside the spotlight render with the correct contrast.

```html
<div class="surface-spotlight p-4">
  <p class="text-strong">I am in a dark context (if the page is light)!</p>
  <!-- Native checkbox will be dark-themed -->
  <input type="checkbox" />
</div>
```

## Framework Examples

### React

```tsx
function Card({ title, children }) {
  return (
    <div className="surface-card p-4 rounded-lg">
      <h3 className="text-strong text-lg font-bold">{title}</h3>
      <div className="text-subtle mt-2">{children}</div>
    </div>
  );
}
```

### Tailwind CSS

The Color System plays nicely with Tailwind. You can use Tailwind for layout (`p-4`, `flex`, `rounded`) and the Color System for... well, color.

If you want to use the Color System's tokens _inside_ Tailwind utility classes (e.g., `bg-surface-card`), you can configure your `tailwind.config.js` to map to the CSS variables.

_Note: A dedicated Tailwind plugin is on the roadmap._

### Tailwind Configuration

To use the system's tokens within Tailwind classes (e.g., `bg-surface-card`), add this to your `tailwind.config.js`:

```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  theme: {
    extend: {
      colors: {
        // Map semantic surfaces
        surface: {
          page: "var(--surface-page)",
          card: "var(--surface-card)",
          action: "var(--surface-action)",
        },
        // Map semantic text
        text: {
          strong: "var(--text-strong)",
          subtle: "var(--text-subtle)",
        },
      },
    },
  },
};
```

---

## guides/linting.mdx

The Axiomatic Color System provides an ESLint plugin to help you maintain a clean, consistent codebase. The plugin enforces the "Code is Truth" axiom by flagging hardcoded colors and ensuring semantic token usage.

## Installation

```bash
pnpm add -D @axiomatic-design/eslint-plugin
```

## Configuration

Add the plugin to your `eslint.config.js` (flat config):

```javascript


export default [
  {
    plugins: {
      "@axiomatic-design": axiomatic,
    },
    rules: {
      // Warn on hardcoded colors (hex, rgb, etc.)
      "@axiomatic-design/no-hardcoded-colors": "warn",

      // Error on invalid or internal token usage
      "@axiomatic-design/no-raw-tokens": "error",
    },
  },
];
```

## Rules

### `no-hardcoded-colors`

This rule flags usage of hardcoded color values (Hex, RGB, HSL, named colors) in your code. It supports JSX `style` props, Svelte, Vue, and Ember (GTS) templates.

**Why?**
Hardcoded colors break the system's ability to adapt to themes and modes. They are "Magic Numbers" that should be replaced with semantic tokens.

**Example:**

```jsx
// ❌ Invalid
<div style={{ color: "red" }}>Error</div>

// ✅ Valid
<div className="text-strong">Error</div>
```

**Auto-Fix:**
The rule provides auto-fix suggestions to replace hardcoded colors with the closest matching semantic token from your generated theme.

### `no-raw-tokens`

This rule flags usage of internal tokens, non-existent tokens, or tokens that should be applied via utility classes.

**Why?**

- **Internal Tokens**: Tokens like `--scale-gray-500` are implementation details and may change. Use semantic tokens like `--surface-sunken` instead.
- **Utility Classes**: Some tokens (like shadows or surfaces) carry extra properties or side effects. Using the utility class ensures consistent behavior.

**Example:**

```javascript
// ❌ Invalid (Internal Token)
const color = "var(--scale-gray-500)";

// ❌ Invalid (Should use class)
const bg = "var(--surface-card)";

// ✅ Valid
<div className="surface-card text-strong" />;
```

## Config Awareness

The plugin is "Config Aware". It automatically detects your `color-config.json` and generated theme CSS (commonly `css/theme.css` or `theme.css`) to validate tokens and provide accurate suggestions.

If your project also has a separate utilities stylesheet, the plugin can use it to map tokens back to recommended classes, but it is not required.

Ensure these files are present in your project root or build output for the linter to work correctly.

---

## guides/quick-start.mdx

:::caution[Alpha Release]
This is an alpha release. See [Alpha Limitations](/alpha-limitations) for current gaps and known issues.
:::

This guide will walk you through setting up the Axiomatic Color and building your first themed component.

## 1. Install & Initialize

Run the following commands in your project root:

`pnpm` is recommended (this repo uses pnpm). `npm` generally works as a best-effort alternative.


  

    ```bash
    npm install -D @axiomatic-design/color
    npx axiomatic init
    ```

  
  

    ```bash
    pnpm add -D @axiomatic-design/color
    pnpm exec axiomatic init
    ```

  


This creates a `color-config.json` file with default settings.

## 2. Generate Assets

Now, generate the CSS and TypeScript definitions.


  

    ```bash
    npx axiomatic build --out ./src/theme.css
    npx axiomatic export --format typescript --out ./src/theme.ts
    ```

  
  

    ```bash
    pnpm exec axiomatic build --out ./src/theme.css
    pnpm exec axiomatic export --format typescript --out ./src/theme.ts
    ```

  


## 3. Build a Card

Let's build a simple "Card" component to see the system in action.


  
  
  First, import the engine and your generated theme in your app entry point:
  ```tsx
  import "@axiomatic-design/color/engine.css";
  import "./theme.css";
  ```

Then, create a Card component:

```tsx
export function Card() {
  return (
    <div
      className="surface-card"
      style={{ padding: "2rem", borderRadius: "8px" }}
    >
      <h2 className="text-strong">Hello World</h2>
      <p className="text-subtle">I am a themed card.</p>
    </div>
  );
}
```

  

  
  
  First, import the engine and your generated theme in your root layout:
  ```svelte
  <script>
    import "@axiomatic-design/color/engine.css";
    import "../theme.css";
  </script>
  <slot />
  ```

Then, create a Card component:

```svelte
<script>
  import { tokens } from "$lib/theme";
</script>

<div class={tokens.surface.card} style="padding: 2rem; border-radius: 8px;">
  <h2 style="color: {tokens.context.text.high}">Hello World</h2>
  <p style="color: {tokens.context.text.subtle}">I am a themed card.</p>
</div>
```

  

  
  
  Link the engine and your generated theme in your `<head>`:
  
  > **Note**: If you are using a bundler (like Vite, Webpack, or Astro), you should import the CSS file in your JavaScript/TypeScript entry point instead (e.g. `import './theme.css'`).

```html
<link
  rel="stylesheet"
  href="https://unpkg.com/@axiomatic-design/color@latest/engine.css"
/>
<link rel="stylesheet" href="./src/theme.css" />
```

Then, write the markup using the utility classes:

```html
<div class="surface-card" style="padding: 2rem; border-radius: 8px;">
  <h2 class="text-strong">Hello World</h2>
  <p class="text-subtle">I am a themed card.</p>
</div>
```

  


## 4. Next Steps

You now have a working theme system!

- **[React Integration](./frameworks/react)**: Deep dive into React patterns.
- **[Svelte Integration](./frameworks/svelte)**: Deep dive into Svelte patterns.
- **[The Theme Studio](./theme-builder)**: Customize your colors visually.

---

## guides/theme-builder.md

The **Theme Studio** is a web-based tool that allows you to visually design your theme and export the configuration for your project.

<div class="docs-cta-container">
    <a href="/studio/" class="docs-cta-button surface-action hue-brand bordered">
    Launch Theme Studio →
  </a>
</div>

## Workflow

The Theme Studio is designed to work hand-in-hand with the CLI.

1.  **Design**: Use the visual controls to adjust anchors, key colors, and surfaces.
2.  **Export**: Click the "Export Config" button to get your JSON.
3.  **Paste**: Copy the JSON into your local `color-config.json`.
4.  **Build**: Run `pnpm exec axiomatic build` (or best-effort `npx axiomatic build`) to generate your CSS.

## Key Features

### 1. Anchor Tuning

The most powerful feature of the studio is the **Anchor Tuner**.

- **Background Anchors**: Drag the sliders to change the "start" (page background) and "end" (highest surface) lightness. Watch how every surface in the preview updates instantly.
- **Foreground Anchors**: Adjust the contrast range for text.

### 2. Semantic Colors

You can define your semantic hues (Brand, Success, Danger, etc.) and see how they look across different surfaces.

- **Hue**: Pick the base hue.
- **Chroma**: Adjust the saturation.
- **Usage**: See how the color looks as a button (`surface-action`), a badge (`surface-tinted`), or text (`text-link`).

### 3. Real-time Accessibility Check

As you drag sliders, the studio runs the **APCA Solver** in real-time.

- If you make the background too dark for the text, the text will automatically lighten to maintain readability.
- If you create a combination that is mathematically impossible to solve (e.g., low contrast background + low contrast text), the studio will warn you.

## Importing an Existing Config

If you already have a `color-config.json`, you can paste it into the "Import" tab of the Theme Studio to visualize your current theme and make adjustments.

---

## index.mdx

> **Axiomatic Color** is a CSS framework and CLI that automates accessibility, dark mode, and consistency using a physics-based constraint solver.

## At a Glance: Build a Profile Card

In this 5-minute tutorial, you'll build a fully accessible, dark-mode ready UI component without picking a single hex code.

### Step 1: The Page Surface

Everything starts with a **Surface**. Surfaces provide context for the content inside them. The `surface-page` is your canvas.

<Snippet name="layout-stack" />

### Step 2: Adding a Card

Nest a `surface-card` inside the page. The system automatically adjusts the contrast and borders to ensure it stands out.

<Snippet name="card" />

### Step 3: Adding Interactivity

Add a button using `surface-action`. Notice how we use `hue-brand` to apply your brand color, while the system handles the text contrast automatically.

<Snippet name="button" />

### Step 4: Inputs

Form elements are surfaces too.

<Snippet name="input" />

## Why This Matters


  
    The system uses **APCA** (the future WCAG 3.0 standard) to mathematically
    guarantee readability. If your background changes, your text automatically
    adjusts to maintain contrast.
  
  
    Don't maintain two separate palettes. The system understands **Polarity**.
    It automatically inverts your surfaces and recalculates contrast for dark
    mode, ensuring a perfect visual balance.
  
  
    Components adapt to their environment. A "Secondary Text" class looks
    different on a white card than it does on a dark tooltip, but it always
    maintains the same *semantic weight*.
  
  
    Built on the cutting edge of the web platform: **OKLCH**, **Relative Color
    Syntax**, and **CSS Custom Properties**. No JavaScript runtime required for
    the final output.
  
</CardGrid>

---

## philosophy.md

Axiomatic Color is built on three core pillars: **Math**, **Semantics**, and **Adaptability**.

## Math vs. Magic

Most color systems are built on **Magic Numbers**.

> "Use `Blue-500` for buttons and `Gray-100` for cards."

This forces **you** to be the calculator.

1.  **Is it accessible?** You have to know that `Blue-800` is safe on `Blue-200`. Is `Blue-500` safe? You have to check a table.
2.  **What about Dark Mode?** `Blue-800` on `Blue-200` might work in Light Mode, but in Dark Mode, you need to invert it. Now you're managing two sets of magic numbers.
3.  **Is it consistent?** The math of perception is non-linear. A step of "100" in lightness looks different in dark mode than in light mode. To make them _feel_ the same, you have to manually tweak the values.

This system is built on **Math**.

> "I need a Card."

The system translates this intent into a mathematical rule: _Must have APCA 60 contrast against the background._

The **Solver** handles the complexity for you:

- **It guarantees contrast**: It picks the exact lightness to hit APCA 60.
- **It handles polarity**: It automatically flips for Dark Mode.
- **It balances perception**: It adjusts the lightness steps so that "contrast" feels the same in both modes.
- **It shifts hue**: It automatically warms up lighter colors and cools down darker colors (the "Bezold–Brücke effect") so you don't have to manually pick "warmer" grays.

**You define the intent. The system solves the math.**

## Designing with Intent

Our semantic roles (like "Surface", "Action", "Link") are not arbitrary choices. They are derived directly from the **fundamental semantics of the web platform**.

By aligning our taxonomy with these platform primitives, we ensure that accessibility is not an "add-on" or a "special case." It is the **foundation** of the design. When you design with these concepts, you are designing with the grain of the web, ensuring your application feels native and works perfectly for every user, regardless of their device or settings.

> **For the curious:** Under the hood, we map these roles to CSS System Colors (like `Canvas`, `ButtonFace`, `Highlight`). This is how we support Windows High Contrast mode automatically. But you don't need to know that to use the system—just use the semantic names.

## The Reactive Pipeline

How does this actually work in the browser?

The details below are explanatory only. You should not need to use internal variables or engine mechanics directly to integrate Axiomatic Color.

<!-- axm-docs:explanatory:start -->

We use a technique called the **Reactive Pipeline**. Instead of hardcoding hex values into classes, we use CSS Custom Properties (`var(--...)`) and the Relative Color Syntax (`oklch(from ...)`).

<!-- axm-docs:explanatory:end -->

### The Flow

1.  **Input Variables**: You set high-level intent variables.

    <!-- axm-docs:explanatory:start -->

    ```css
    .hue-brand {
      --hue-brand: 250;
    }
    ```

    <!-- axm-docs:explanatory:end -->

2.  **The Engine (`engine.css`)**: The engine listens to these variables and recalculates the colors in real-time.

  <!-- axm-docs:explanatory:start -->

    ```css
    /* Simplified Engine Logic */
    --computed-surface: oklch(from var(--surface-token) l c var(--hue-brand));
    ```

  <!-- axm-docs:explanatory:end -->

3.  **The Output**: The browser renders the final color.

### Why is this powerful?

- **Instant Theming**: Change `--hue-brand` on the `<body>`, and the entire app updates instantly. No re-compiling CSS.
- **Scoped Theming**: Change `--hue-brand` on a specific `<div>`, and only that section changes color.
- **Animation**: Because these are just numbers, you can animate them! The system handles the color interpolation for you.

---

## reference/cli.md

The `axiomatic` CLI is the primary tool for generating your theme tokens.

## Installation

```bash
pnpm add -D @axiomatic-design/color

# Best-effort (pnpm is recommended for this repo)
npm install -D @axiomatic-design/color
```

## Usage

```bash
# Recommended when installed as a dev dependency
pnpm exec axiomatic [command] [options]

# One-off / quick try
npx axiomatic [command] [options]
```

## Commands

### `init`

Scaffolds a new configuration file in your project.

```bash
npx axiomatic init
```

**Behavior:**

- Checks if `color-config.json` exists.
- If not, creates it with the default configuration (including the `$schema` reference).
- If it exists, exits with an error to prevent overwriting.

### `build` (Default)

Generates the CSS tokens based on your configuration. If no command is specified, this is the default behavior.

```bash
npx axiomatic build [options]
```

**Options:**

- `--config <path>`: Path to your JSON configuration file. (Default: `./color-config.json`)
- `--out <path>`: Path where the generated CSS will be written. (Default: `./theme.css`)
- `--watch`: Watch for changes in the config file and rebuild automatically.
- `--copy-engine`: Copy `engine.css` next to the output CSS (useful for simple integrations).

**Examples:**

```bash
# Use defaults
npx axiomatic build

# Watch mode
npx axiomatic build --watch

# Custom paths
npx axiomatic build --config ./design/colors.json --out ./src/variables.css

# Copy engine.css next to your output
npx axiomatic build --copy-engine
```

**Notes:**

- `build` also emits a class-token manifest alongside your CSS output:
  - If `--out` is `theme.css`, you’ll also get `theme.class-tokens.json`.
  - Otherwise you’ll get `<out>.class-tokens.json`.
- If you run `axiomatic` with no command, it runs `build`.

### `export`

Exports your theme tokens to other formats (DTCG, Tailwind, TypeScript).

```bash
npx axiomatic export [options]
```

**Options:**

- `--format <format>`: The output format. Supported: `dtcg`, `tailwind`, `typescript`. (Default: `dtcg`)
- `--out <path>`: Output file or directory.
  - For `dtcg`: Defaults to `./tokens/` (Directory).
  - For `tailwind`: Defaults to `./tailwind.preset.js`.
  - For `typescript`: Defaults to `./theme.ts`.
- `--config <path>`: Path to config file.

**Examples:**

```bash
# Export DTCG tokens to ./tokens/ directory
npx axiomatic export --format dtcg

# Export as a single JSON file
npx axiomatic export --format dtcg --out tokens.json

# Export Tailwind preset
npx axiomatic export --format tailwind
```

### `audit`

Audits your configuration and generated theme for accessibility and logic errors.

```bash
npx axiomatic audit
```

**Checks:**

- **Schema Validation**: Ensures your JSON config matches the schema.
- **Contrast Compliance**: Verifies that all surfaces meet APCA contrast guidelines.
- **Polarity Logic**: Ensures "Page" surfaces are light in Light Mode, and "Inverted" surfaces are dark.

**Semantics:**

`audit` is designed to be **advisory**: it reports schema and logic findings, but not every finding is treated as a hard failure.

### `import`

Imports a DTCG token file into an Axiomatic configuration.

```bash
npx axiomatic import <file> [--out <file>] [--dry-run]
```

**Notes:**

- Intended as a migration tool: it produces a `color-config.json`-compatible output.

## Output

The `build` command generates a CSS file containing:

1.  **:root Variables**: Global tokens like shadows, focus rings, and data viz colors.
2.  **Surface Classes**: Classes for each surface defined in your config (e.g., `.surface-card`).
3.  **High Contrast Media Query**: A `@media (prefers-contrast: more)` block with accessible overrides.

It also generates a class-token manifest (`*.class-tokens.json`) which is used for enforcement and tooling.

### Integration

Import the generated file in your main CSS entry point:

```css
@import "@axiomatic-design/color/engine.css";
@import "./theme.css";
```

### Legacy shorthand

For compatibility, the CLI supports the legacy shorthand form:

```bash
npx axiomatic <config> <out>
```

This is treated as `build --config <config> --out <out>`.

---

## reference/example.md

Reference pages are ideal for outlining how things work in terse and clear terms.
Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what you're documenting.

## Further reading

- Read [about reference](https://diataxis.fr/reference/) in the Diátaxis framework

---

## reference/javascript-api.md

The Runtime API allows you to manage the theme mode and sync it with the browser environment.

## `ThemeManager`

The `ThemeManager` class is the main entry point for runtime theme control.

```typescript

```

### Constructor

```typescript


const themeManager = new ThemeManager({ invertedSelectors });
```

**Options:**

| Option              | Type                        | Default                    | Description                                                                 |
| :------------------ | :-------------------------- | :------------------------- | :-------------------------------------------------------------------------- |
| `invertedSelectors` | `readonly string[]`         | (required)                 | Selectors for surfaces with inverted polarity. Import from generated file. |
| `root`              | `HTMLElement`               | `document.documentElement` | The element to apply the theme to.                                          |
| `faviconGenerator`  | `(color: string) => string` | `undefined`                | Function to generate an SVG favicon based on the current theme color.       |
| `theme`             | `AxiomaticTheme`            | `AxiomaticTheme.get()`     | Optional theme instance for dependency injection. Useful for testing.      |

### Methods

#### `setMode(mode: ThemeMode)`

Sets the active theme mode.

- **`mode`**: `"light" | "dark" | "system"`

```typescript
themeManager.setMode("dark");
```

#### `get mode()`

Returns the current configured mode (e.g., `"system"`).

#### `get resolvedMode()`

Returns the actual active mode (`"light"` or `"dark"`). If mode is `"system"`, this returns the OS preference.

#### `dispose()`

Cleans up event listeners (e.g., for system preference changes). Call this when unmounting your app or component.

### Interaction with Inverted Surfaces

The `ThemeManager` sets the global theme state on the root element. The generated CSS uses this state to automatically flip the `color-scheme` for inverted surfaces (like `surface-spotlight`).

No extra JavaScript is required to handle these local inversions.

## Helper Functions

### `updateThemeColor()`

Updates the `<meta name="theme-color">` tag to match the computed background color of the document body. This is called automatically by `ThemeManager`, but you can export and use it manually if needed.

```typescript


updateThemeColor();
```

### `updateFavicon(generator)`

Updates the favicon dynamically.

```typescript


updateFavicon(
  (color) => `
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
    <circle cx="16" cy="16" r="14" fill="${color}" />
  </svg>
`,
);
```

---

## reference/tokens.mdx

This page distinguishes the **public token surfaces** you should build against from the **engine variables** that exist for implementation, diagnostics, and advanced interop.

Most applications should prefer:

- Semantic classes (e.g. `surface-card`, `text-subtle`, `hue-brand`)
- Exported tokens (for example from `axiomatic export --format typescript`)

If you directly depend on `--axm-*` CSS variables, treat them as an advanced escape hatch rather than the default integration surface.

## Public surfaces

### Semantic classes

The primary “token surface” is the set of semantic classes generated and shipped by the system.

- Surfaces: `surface-page`, `surface-card`, `surface-action`, …
- Text: `text-strong`, `text-subtle`, …
- Hue modifiers: `hue-brand`, `hue-danger`, …

### Exported tokens (recommended for libraries)

If you are building custom primitives or a component library, prefer consuming exported tokens (TypeScript/DTCG/Tailwind) rather than reading engine CSS variables.

## Internals / interop (engine CSS variables)

{/* axm-docs:explanatory:start */}

These variables are scoped to the current surface context (e.g., inside `.surface-card`) and change as nesting/context changes. They are useful for diagnostics and advanced interop, but are not the preferred day-to-day surface.

<div class="surface-card p-6 rounded-lg border border-border-dec mb-8">

| Token                       | Description                                                     |
| :-------------------------- | :-------------------------------------------------------------- |
| `--axm-surface-token`       | The background color of the current surface.                    |
| `--axm-text-high-token`     | High-contrast text color (e.g., Black on Light, White on Dark). |
| `--axm-text-subtle-token`   | Lower-contrast text color for secondary information.            |
| `--axm-text-subtlest-token` | Lowest-contrast text color for placeholders or disabled text.   |
| `--axm-border-dec-token`    | Decorative border color (low contrast).                         |
| `--axm-border-int-token`    | Interactive border color (higher contrast).                     |

</div>

### Usage

Prefer using the utility classes (like `.text-strong`, `.surface-card`) instead of accessing these tokens directly. This ensures your UI remains consistent with the system's composition model.

{/* axm-docs:explanatory:end */}

## Utility Classes

These utility classes provide a semantic layer over the raw tokens.

### Context Accessors

These utilities allow elements to "read" the current surface context and apply it to specific properties. Use these when you need an element to match the _current_ surface (e.g., for masking or blending) without creating a new surface context.

<div class="surface-card p-6 rounded-lg border border-border-dec mb-8">

| Class             | Description                                   |
| :---------------- | :-------------------------------------------- |
| `.bg-surface`     | Sets `background-color` to the surface token. |
| `.border-surface` | Sets `border-color` to the surface token.     |
| `.stroke-surface` | Sets SVG `stroke` to the surface token.       |

</div>

### Interaction States

These utilities apply system-wide interaction styles, ensuring consistency for focus and selection states.

<div class="surface-card p-6 rounded-lg border border-border-dec mb-8">

| Class                 | Description                                      |
| :-------------------- | :----------------------------------------------- |
| `.ring-focus`         | Applies a static focus ring.                     |
| `.ring-focus-visible` | Applies a focus ring only on `:focus-visible`.   |
| `.border-highlight`   | Sets `border-color` to the highlight ring color. |

</div>

### Composition

You can compose surface classes with hue utilities to create colored surfaces.

```html
<!-- A button with the highlight color -->
<button class="surface-action hue-highlight">Click Me</button>
```

## Global Tokens

These tokens are defined on `:root` and are available everywhere.

### Elevation (Shadows)

{/* axm-docs:explanatory:start */}

<div class="surface-card p-6 rounded-lg border border-border-dec mb-8">

| Token             | Description                                   |
| :---------------- | :-------------------------------------------- |
| `--axm-shadow-sm` | Small shadow for subtle depth.                |
| `--axm-shadow-md` | Medium shadow for cards and dropdowns.        |
| `--axm-shadow-lg` | Large shadow for modals and floating actions. |
| `--axm-shadow-xl` | Extra large shadow for major overlays.        |

</div>

{/* axm-docs:explanatory:end */}

### Focus

{/* axm-docs:explanatory:start */}

<div class="surface-card p-6 rounded-lg border border-border-dec mb-8">

| Token                    | Description                                 |
| :----------------------- | :------------------------------------------ |
| `--axm-focus-ring-color` | The brand-aware color used for focus rings. |

</div>

{/* axm-docs:explanatory:end */}

### Data Visualization

If you have configured a palette in `color-config.json`, these tokens will be available.

{/* axm-docs:explanatory:start */}

<div class="surface-card p-6 rounded-lg border border-border-dec mb-8">

| Token           | Description                             |
| :-------------- | :-------------------------------------- |
| `--axm-chart-1` | First color in the categorical palette. |
| `--axm-chart-2` | Second color...                         |
| ...             | ...                                     |
| `--axm-chart-N` | Nth color.                              |

</div>

{/* axm-docs:explanatory:end */}

## Internal Tokens

You may see these tokens in the generated CSS, but they are generally intended for internal use by the engine.

{/* axm-docs:explanatory:start */}

- `--axm-chroma-brand`: The base chroma value derived from your key colors.
- `--axm-hue-brand`: The base hue value derived from your key colors.

{/* axm-docs:explanatory:end */}

---

## reference/troubleshooting.mdx

This guide covers common issues encountered during alpha testing. Many sections are **skeletal**—they'll expand based on your feedback as we approach beta.

:::note
If you encounter an issue not covered here, please [file a GitHub issue](https://github.com/design-axioms/color/issues) with reproduction steps and your `color-config.json`.
:::

---

## Theme Not Switching

### Symptom
Clicking the theme toggle doesn't change colors, or changes happen inconsistently.

### Causes & Solutions

#### ThemeManager Not Initialized

The `AxiomaticTheme` singleton must be initialized before the DOM is rendered. If you're seeing console errors like `Cannot read property 'subscribe' of undefined`:

```tsx
// ❌ Bad: ThemeManager imported but never initialized


// ✅ Good: Initialize on app startup

const themeManager = AxiomaticTheme.get(); // Initializes singleton
```

See the [React Integration](/guides/frameworks/react) guide for framework-specific patterns.

#### Missing `data-axm-resolved-mode` Attribute

The engine requires `<html data-axm-resolved-mode="light">` (or `"dark"`) to apply the correct polarity anchors. If this attribute is missing or out of sync:

1. Check that your ThemeManager integration is updating the DOM:
   ```ts
   themeManager.subscribe((state) => {
     document.documentElement.dataset.axmResolvedMode = state.mode;
   });
   ```

2. Verify SSR hydration isn't removing the attribute (common in Next.js/SvelteKit).

**Workaround**: For static sites, manually set the attribute on page load:
```html
<script>
  document.documentElement.dataset.axmResolvedMode = 
    localStorage.getItem("axm-theme-mode") || "light";
</script>
```

#### Conflicting CSS Transitions

If colors "flicker" or transition unpredictably, another stylesheet may be overriding `transition-property`. Check DevTools for rules targeting `*` or `:root` that modify transitions.

**Debug**: Temporarily add this to your entry CSS:
```css
:root {
  transition: none !important;
}
```

If this fixes the flicker, you have a specificity conflict. See [Integration Conflicts](#integration-conflicts) below.

---

## Colors Look Wrong

### Symptom
Text is too light, backgrounds are unexpected, or colors don't match your brand.

### Causes & Solutions

#### Missing Surface Class (No Context)

**Most common issue**: If you see default grays instead of your brand colors, you likely forgot to wrap content in a surface class.

```html
<!-- ❌ No surface = no context = default fallbacks -->
<div class="text-high">Hello</div>

<!-- ✅ Surface establishes context -->
<div class="surface-page">
  <div class="text-high">Hello</div>
</div>
```

The engine cannot compute colors without knowing which surface you're on. See [Thinking in Surfaces](/concepts/thinking-in-surfaces) for the mental model.

#### Alpha/Beta Chroma Settings

If brand colors look "washed out" or "too vibrant", check your `color-config.json`:

{/* axm-docs:explanatory:start */}

```json
{
  "anchors": {
    "keyColors": {
      "brand": "oklch(60% 0.15 260)" // ← Chroma too low?
    }
  }
}
```

{/* axm-docs:explanatory:end */}

- **Chroma too low** (&lt;0.10): Colors will appear grayish, especially in light mode.
- **Chroma too high** (&gt;0.25): Colors may clip in dark mode or fail gamut checks.

**Recommended range**: 0.12–0.20 for most hues. See the [Theme Studio](/studio/) for interactive tuning.

#### Browser Doesn't Support OKLCH

Axiomatic requires **OKLCH color space support**. This is available in:

- Chrome/Edge 111+
- Safari 16.4+
- Firefox 113+

If you see gray boxes or `transparent` colors in DevTools, check your browser version. Older browsers will silently fail to parse OKLCH color values.

**Workaround**: None for alpha. We're evaluating polyfills for beta, but this adds ~30KB and CPU overhead. File an issue if this is blocking you.

---

## Build Errors

### Common pnpm/npm Issues

#### `Cannot find module '@axiomatic-design/color'`

You're using `npm` or `yarn` in a workspace that requires `pnpm`. Install pnpm globally:

```bash
npm install -g pnpm
pnpm install
```

Mixing package managers causes lockfile conflicts and phantom dependency issues.

#### `ERR_PNPM_PEER_DEP_ISSUES`

Peer dependency warnings are **expected** in alpha. As long as the install completes, you can safely ignore them. We'll resolve these before beta.

### Node Version Requirements

Axiomatic requires **Node 24+** for native TypeScript execution. If you see:

```
SyntaxError: Unexpected token 'export'
```

Check your Node version:
```bash
node --version  # Should be v24.x.x
```

**Workaround for older Node**: Not supported in alpha. Upgrade via [nvm](https://github.com/nvm-sh/nvm) or [fnm](https://github.com/Schniz/fnm).

### Missing Dependencies

If you encounter `Cannot find module 'chroma-js'` or similar:

1. Run `pnpm install` from the **workspace root** (not a subdirectory).
2. Check that `node_modules/@axiomatic-design/color` exists.
3. If using a monorepo, verify `pnpm-workspace.yaml` includes the correct packages.

More patterns will be added based on alpha feedback.

---

## Contrast Violations in Inspector

### Understanding the Diagnosis

The Inspector flags contrast violations using **APCA** (not WCAG 2.x ratios). A violation means the solver **couldn't meet the target contrast** for that surface/text combination.

Open the Inspector (keyboard shortcut: `Alt+Shift+I` or click the floating icon) to see:

- **Red outline**: Element with a violation
- **Provenance panel**: Shows which CSS variables contributed to the computed color
- **Diagnosis**: Explains why the solver failed (e.g., "Chroma too high, gamut clipped")

### How to Fix

#### Option 1: Adjust Class Tokens (Recommended)

If `.text-high` on `.surface-card` violates contrast, try a higher-contrast token:

```html
<!-- Before -->
<div class="surface-card">
  <p class="text-high">This might fail</p>
</div>

<!-- After: Use body (mid-contrast) or subtle (low-contrast) -->
<div class="surface-card">
  <p class="text-body">This should pass</p>
</div>
```

The token hierarchy is: `text-high` (strongest) > `text-body` > `text-subtle` (weakest).

#### Option 2: Adjust Solver Config

If violations are systemic (e.g., _all_ text on `.surface-inverted` fails), your config may need tuning:

```json
{
  "contrastTargets": {
    "body": 75,
    "high": 90
  }
}
```

Re-run the CLI solver after config changes.

#### Option 3: Override Manually (Last Resort)

If the solver cannot meet your requirements (e.g., you need a specific brand color that inherently has low contrast), you can override:

{/* axm-docs:explanatory:start */}

```css
.my-special-case {
  --axm-text-high-token: oklch(20% 0.05 260);
}
```

{/* axm-docs:explanatory:end */}

But this **disables the physics engine** for that element. Use sparingly.

### False Positives (Container Queries)

**Known issue**: The Inspector currently misreports violations inside `@container` query blocks. See [Alpha Limitations](/alpha-limitations) for details.

**Workaround**: Manually verify contrast using browser DevTools or the [APCA calculator](https://www.myndex.com/APCA/).

This will be fixed in beta.

---

## Integration Conflicts

### Framework Overriding Axiomatic Variables

If a UI framework (e.g., Chakra UI, Material UI) sets its own `--primary` or `--background` variables, you may see conflicts.

#### Diagnosis

1. Open DevTools → Elements → Inspect the problematic element
2. Check the **Computed** tab for Axiomatic variables like `--axm-bridge-fg-high`
3. If they're missing or overridden, another stylesheet is winning the specificity battle

#### Solution A: Namespace Your Styles

Wrap your Axiomatic surfaces in a container class:

```html
<div class="app-axiomatic">
  <div class="surface-page">
    <!-- Axiomatic styles apply here -->
  </div>
</div>
```

#### Solution B: Load Order

Ensure `engine.css` loads **after** framework styles in your build pipeline. Axiomatic's base specificity is low by design (to allow easy overrides), but it assumes it's the last loaded theme system.

More patterns will be added based on alpha feedback.

### CSS Specificity Battles

If Tailwind or another utility framework is overriding Axiomatic classes:

{/* axm-docs:explanatory:start */}

```html
<!-- Tailwind wins -->
<div class="surface-page bg-white text-black">
```

{/* axm-docs:explanatory:end */}

**Workaround**: Don't mix Axiomatic class tokens with framework utility classes. Choose one system per component.

### Multiple Theme Systems

Running two theme systems simultaneously (e.g., Axiomatic + Tailwind's dark mode) will cause undefined behavior. Axiomatic assumes it **owns** `background-color`, `color`, and `border-color` for elements using its class tokens.

**Migration strategy**: Incrementally adopt Axiomatic per-component. Don't try to theme the entire app at once.

More patterns will be added based on alpha feedback.

---

## Still Stuck?

If this guide doesn't cover your issue:

1. **Check existing issues**: [GitHub Issues](https://github.com/design-axioms/color/issues)
2. **File a new issue** with:
   - Your `color-config.json`
   - Minimal reproduction code (CodeSandbox, StackBlitz, or repo link)
   - Browser version and OS
3. **Join discussions**: See [Contributing](https://github.com/design-axioms/color/blob/main/CONTRIBUTING.md) for community links

Your feedback during alpha is invaluable. We're especially interested in **integration challenges** with specific frameworks or build tools.

---

## theory/algebra.mdx

import "@fontsource-variable/eb-garamond";

<TufteLayoutActivator />

> _Context_: The physics and grammar of the color system.[^axiomatic]

This document defines the "Physics" of the color system. It replaces the previous static heuristic model with a _Reactive Physics Model_ based on continuous state interpolation.

## 1. The State Space ($\Sigma$)

> **Definition 1** (State Configuration $\Sigma$). The system configuration is a 5-tuple $\Sigma = \langle \alpha, \mathcal{V}, \tau, \gamma, \mu \rangle$ where:

1.  **Atmosphere** ($\alpha$): The environmental vector $\alpha = \langle H, \beta \rangle$.
    - $H \in S^1$: _Hue_. The base angle of the environment.
    - $\beta \in [ 0, 1 ]$: _Vibrancy Coefficient_. A scalar multiplier acting on the maximum potential chroma ($C$) of the environment.
2.  **Voice** ($\mathcal{V}$): The semantic intent.
    - Let $T$ be the set of pre-solved lightness constants derived by the lighting function $f_L$ (see Section 2.1).
    - $\mathcal{V} \in T$: A reference to a specific semantic intent (e.g., _High Contrast_).
      > 
        In the Axiomatic system, intents map to tokens like `text-high` and
        `text-subtle`.
      
3.  **Time** ($\tau$): The normalized temporal parameter.
    - $\tau \in [ -1, 1 ]$: Represents the shift from Night ($-1$) to Day ($+1$).
4.  **Gain** ($\gamma$): The user's contrast preference.
    - $\gamma \in [ 1, \infty )$. Amplifies the _Voice_ ($\mathcal{V}$) target contrast. Used for _High Contrast Mode_.
5.  **Mode** ($\mu$): The rendering technique.
    - $\mu \in \{ 0, 1 \}$:
      - 0: _Rich Mode_ (Standard).
      - 1: _X-Ray Mode_ (Forced Colors).[^remark1]

[^remark1]: **Remark**:

    - **Atmosphere**: The "Weather" of the room.
    - **Voice**: The "Script".
    - **Time**: The "Clock".
    - **Gain**: The "Volume Knob". (Turn it up for High Contrast).
    - **Mode**: The "Physics Engine". (Rich vs. X-Ray).

## 2. The Architecture: Static Initialization vs. Runtime Algebra

The system is explicitly split into two domains to guarantee performance and correctness.

### 2.1. Pre-Computation Routine (Static Phase)

The _initialization routine_[^genesis] solves the "Hard Math" (APCA Contrast) offline. It calculates the exact Lightness ($L$) required for a specific Voice ($\mathcal{V}$) to be legible against a specific background.

It also applies a _Helmholtz-Kohlrausch Buffer_ to offset the perceptual lightness of vibrant colors.

$$
\begin{aligned}
\Psi(K, \tau) &\to \mathcal{V}_{\text{constant}} \\
L_{\text{target}} &= L_{\text{APCA}} + (k_{hk} \cdot \beta)
\end{aligned}
$$

These constants are baked into the CSS as variables (e.g., `--text-high-L: 98%`).

### 2.2. Algebra (Render Time)

The _Algebra_ (CSS Engine)[^algebra] is a "Switching Mixer." It resolves the final color based on the System Mode ($\mu$).

$$
\Phi(\Sigma) = \begin{cases}
\Phi_{\text{rich}}(\alpha, \mathcal{V}, \tau, \gamma) & \text{if } \mu = 0 \\
\Phi_{\text{xray}}(\alpha, \mathcal{V}) & \text{if } \mu = 1
\end{cases}
$$

## 3. The Operators

Classes in the system are _Operators_ that transform the state $\Sigma \to \Sigma'$.

### 3.1. The Surface Split

We distinguish between two topological types of surfaces.

#### 3.1.1. Glass Surfaces ($S_{\text{glass}}$)

Glass surfaces are _Filters_. They inherit the Atmosphere ($\alpha$) from their parent but apply _Bicone Dampening_ to ensure the background remains a subtle tint, safe for text.

{/* prettier-ignore */}
$$
S_{\text{glass}}(\langle \alpha, \mathcal{V}, \tau \rangle) = \langle \text{Dampen}(\alpha), \mathcal{V}_{\text{reset}}, \tau \rangle
$$

#### 3.1.2. Solid Surfaces ($S_{\text{solid}}$)

Solid surfaces are _Emitters_. They represent "pre-calculated pairs" (like Primary Buttons) where the color is derived at build-time to be maximal. They do _not_ dampen. They establish a _new_ Atmosphere.

{/* prettier-ignore */}
$$
S_{\text{solid}}(\langle \alpha, \mathcal{V}, \tau \rangle) = \langle \alpha_{\text{new}}, \mathcal{V}_{\text{new}}, \tau \rangle
$$

## 4. The Universal Safety Theorem (Adaptive Clamping)

To guarantee that text is always readable on Glass Surfaces in _Rich Mode_, we enforce the _Universal Safety Theorem_. The Chroma ($C$) of any Glass Surface is mathematically constrained to lie within the _Safe Bicone_.

### 4.1. The Vibrancy Limit ($C_{\text{limit}}$)

The maximum allowed Chroma is the intersection of three functions:

$$
C_{\text{limit}} = \beta(H) \cdot \text{Taper}(L) \cdot \zeta(\tau)
$$

1.  _The Sine Wave_ ($\beta(H)$): The hue-dependent boundary.

    $$
    \beta(H) = C_{\text{floor}} + (C_{\text{ceil}} - C_{\text{floor}}) \cdot \left( \frac{1 + \sin(H + \phi)}{2} \right)
    $$

2.  _The Bicone Taper_ ($\text{Taper}(L)$): The lightness-dependent boundary. Defined as a _Linear Taper_ (Absolute Value).

    > 
      The linear absolute value ensures precise containment within the sRGB
      gamut.
    

    $$
    \text{Taper}(L) = 1 - |2L - 1|
    $$

3.  _The Tunnel_ ($\zeta(\tau)$): The motion-dependent boundary. Defined as a _Parabolic Ease_ function.

    > 
      Parabolic easing prevents velocity shock (derivative discontinuity) during
      state transitions.
    

    $$
    \zeta(\tau) = \tau^2
    $$

    [^remark2]

[^remark2]: **Remark**:

    - _The Sine Wave_: Yellows can be brighter than Blues.
    - _The Bicone_: As you get closer to White or Black, the allowed chroma drops linearly to zero.
    - _The Tunnel_: During the twilight transition, we dim the colors to ensure safety.

### 4.2. The Dampening Function

For Glass Surfaces, the resolved Chroma is the minimum of the requested Vibrancy and the Limit.

{/* prettier-ignore */}
$$
C_{\text{resolved}} = \min(C_{\text{requested}}, C_{\text{limit}})
$$

## 5. The Hollow State (X-Ray Mode)

When $\mu = 1$ (Forced Colors), the system enters _X-Ray Mode_.

- _Physics is Disabled_: The Bicone/Tunnel math is skipped.
- _Topology is Transformed_: Surfaces are no longer defined by _Area_ (Background Color) but by _Boundary_ (Border).

$$
P(\alpha) \to \text{BorderWidth} \times \text{SystemColor}
$$

This ensures that the semantic structure of the UI is preserved even when the operating system strips all background colors.

## 6. Summary

1.  _State is Unified_: $\Sigma = \langle \alpha, \mathcal{V}, \tau, \gamma, \mu \rangle$.
2.  _Safety is Geometric_: The _Safe Bicone_ ensures text legibility by clamping Chroma linearly.
3.  _Mode is Topological_: _Rich Mode_ paints pixels; _X-Ray Mode_ draws lines (The Hollow State).
4.  _Execution is Split_: The initialization routine solves the goals; Algebra enforces the constraints.

[^axiomatic]: The **Axiomatic Color** system (v4.1).

[^genesis]: The **Genesis Engine** implements this routine in v2.0.

[^algebra]: Implemented by the **Axiomatic CSS** runtime.

---

## theory/proof.mdx

> *Context*: An algebraic derivation showing how the system's state space supports the high-level intuition `Color = f(Context, Intent)`.

## 1. Proposition

The Axiomatic Color system posits that a resolved color is a pure function of two independent variables: *Context* (the environment) and *Intent* (the semantic role).

$$ \text{Color} = f(\text{Context}, \text{Intent}) $$

This document derives this property from the definitions in [The Algebra of Color Design](./algebra.mdx).

## 2. State Space Decomposition

Let the system state $\mathcal{S}$ be defined as the *Configuration Space* of two subspaces: Context ($\Gamma$) and Intent ($\iota$).

$$ \mathcal{S} = \Gamma \times \iota $$

### 2.1. The Subspaces

1.  *Context Space* ($\Gamma$): The environmental variables.
    $$ \Gamma = \text{Hue} \times \text{Chroma} \times \text{Polarity} $$
    $$ \gamma \in \Gamma = \langle H, C, \rho \rangle $$

2.  *Intent Space* ($\iota$): The semantic variables.
    $$ \iota = \text{Tokens} $$
    $$ i \in \iota = \langle L_{src} \rangle $$

Thus, any state $\sigma \in \mathcal{S}$ is an ordered pair:
$$ \sigma = (\gamma, i) $$

> 
We are splitting the system's "DNA" into two separate strands.
*   *Context* ($\Gamma$): The "Atmosphere" (Lighting, Mode).
*   *Intent* ($\iota$): The "Meaning" (Text Importance).

This separation allows us to change the lighting without changing the meaning, and vice versa.


## 3. The Resolution Function ($\Phi$)

The CSS Engine's resolution function $\Phi$ maps the state $\mathcal{S}$ to a color space (OKLCH).

$$ \Phi: (\Gamma \times \iota) \rightarrow \text{Color} $$

$$ \Phi(\langle H, C, \rho \rangle, \langle L_{src} \rangle) = \text{oklch}(\text{eval}(L_{src}, \rho), C, H) $$

**Observation**: The function $\Phi$ accepts $\gamma$ and $i$ as distinct arguments. The evaluation of lightness $\text{eval}(L_{src}, \rho)$ is the only interaction term, representing the "Late Binding" of Intent to Context.

> 
The browser takes the two strands (Atmosphere and Meaning) and weaves them together into a pixel. The only time they "talk" to each other is when the system decides how bright the text should be based on whether it's in Light Mode or Dark Mode.


## 4. Derivation of Independence (Orthogonality)

We define the system operators as transformations on $\mathcal{S}$. To prove independence, we must show that Modifiers ($M$) and Intents ($I$) operate on disjoint subspaces.

### 4.1. Operator Definitions

Let $M$ be a modifier function acting on $\Gamma$, and $I$ be an intent function acting on $\iota$.

$$ M(\gamma, i) = (m(\gamma), i) $$
$$ I(\gamma, i) = (\gamma, k(i)) $$

Where $m: \Gamma \rightarrow \Gamma$ and $k: \iota \rightarrow \iota$ are the specific transformations (e.g., "Set Hue to Brand", "Set Token to Subtle").

### 4.2. Commutativity Proof (General Case)

We examine the composition of these operators in both orders for *Neutral Intents*.

**Case 1**: Intent then Modifier ($M \circ I$)
$$ M(I(\gamma, i)) = M(\gamma, k(i)) = (m(\gamma), k(i)) $$

**Case 2**: Modifier then Intent ($I \circ M$)
$$ I(M(\gamma, i)) = I(m(\gamma), i) = (m(\gamma), k(i)) $$

**Result**:
$$ M \circ I \equiv I \circ M $$

**Conclusion**: For Neutral Intents, the operators commute, and the subspaces $\Gamma$ and $\iota$ are orthogonal.

> 
Because "Subtle Text" only changes Lightness, and "Brand Theme" only changes Color, the order doesn't matter.
*   `class="text-subtle hue-brand"`
*   `class="hue-brand text-subtle"`

Both result in "Subtle Brand-Colored Text."


### 4.3. The Semantic Exception

For *Chromatic Intents* (e.g., Error), the Intent function $I_{chromatic}$ acts on *both* subspaces to enforce semantic meaning.

$$ I_{chromatic}(\gamma, i) = (\gamma_{override}, k(i)) $$

In this case, commutativity is broken ($M \circ I \neq I \circ M$), and the Intent dominates the Context.

> 
An Error Message is *always* Red. It doesn't care if the room is lit with Blue light. The "Error" intent shouts over the ambient lighting, effectively resetting the local atmosphere to Red.


## 5. Surface Scoping

The *Surface Operator* ($S$) is a special transformation that acts on both subspaces.

### 5.1 Glass Surface ($S_{glass}$)
Preserves Context, Resets Intent.
$$ S_{glass}(\gamma, i) = (\gamma, i_{reset}) $$

### 5.2 Solid Surface ($S_{solid}$)
Resets Context, Resets Intent.
$$ S_{solid}(\gamma, i) = (\gamma_{neutral}, i_{reset}) $$

## 6. Summary

By modeling the state $\mathcal{S}$ as the product $\Gamma \times \iota$, we have derived that:

1.  *Separability*: The resolution function $\Phi$ is defined over the pair $(\gamma, i)$.
2.  *Independence*: Operations on $\Gamma$ and $\iota$ are commutative (except for Semantic Dominance).
3.  *Scoping*: Surfaces act as filters that reset $\iota$, and optionally reset $\Gamma$ (if Solid).

This confirms that `Color = f(Context, Intent)` is structurally enforced by the algebra.

---

## why-axiomatic.mdx

## The Problem

Building a modern UI color system is harder than it should be:

- **Dark mode is a full rewrite**: You maintain two separate palettes, and they drift out of sync.
- **Accessibility is manual**: You're constantly checking contrast ratios and adjusting by hand.
- **Colors are context-blind**: A "gray" text needs different values on a white card vs. a dark tooltip, so you end up with `gray-50`, `gray-100`, `gray-200`... and you still guess wrong.

## The Solution

**Axiomatic Color automates the hard parts.**

You define semantic intent (this is a "card", this is "strong text"), and the system handles:

- **Automatic dark mode**: One palette, two appearances. The system inverts surfaces and recalculates contrast for you.
- **Guaranteed accessibility**: Text contrast is mathematically guaranteed using APCA (the future WCAG 3.0 standard).
- **Context-aware colors**: Components adapt to their environment automatically.

## Before vs. After

### Manual CSS (Traditional Approach)

{/* axm-docs:explanatory:start */}

```css
/* You maintain two versions of everything */
.card {
  background: #ffffff;
  color: #1a1a1a;
  border: 1px solid #e5e5e5;
}

.card-title {
  color: #0a0a0a;
}

.card-subtitle {
  color: #737373;
}

/* Dark mode: rewrite everything and hope contrast is okay */
@media (prefers-color-scheme: dark) {
  .card {
    background: #1a1a1a;
    color: #fafafa;
    border: 1px solid #404040;
  }

  .card-title {
    color: #ffffff;
  }

  .card-subtitle {
    color: #a3a3a3; /* Guessing this has enough contrast */
  }
}
```

{/* axm-docs:explanatory:end */}

### With Axiomatic

```css
/* One version. Dark mode just works. */
.card {
  @apply surface-card;
  padding: 2rem;
  border-radius: 8px;
}

.card-title {
  @apply text-strong;
}

.card-subtitle {
  @apply text-subtle;
}
```

The system handles light/dark switching, contrast calculation, and context adaptation automatically.

## Key Benefits

### 🌓 Dark Mode Just Works

Toggle between light and dark mode without maintaining two separate stylesheets. The system automatically inverts surfaces and recalculates all contrast ratios.

### ✅ Accessibility by Default

Text contrast is mathematically guaranteed. If your background changes, your text automatically adjusts to maintain the required contrast level. No more manual WCAG checks.

### 🎨 Semantic, Not Arbitrary

Instead of `color-gray-600`, you use `text-subtle`. The actual color value adapts to the context (page, card, tooltip) while maintaining the same semantic weight.

### 🚀 Modern CSS

Built on cutting-edge web standards: OKLCH color space, Relative Color Syntax, and CSS Custom Properties. No JavaScript runtime needed.

## Ready to Try It?

**[Quick Start →](/guides/quick-start)** - Go from zero to a themed UI in 5 minutes.

**[Try the Studio →](/studio/)** - Customize your theme visually before installing anything.

## When Should You Use Axiomatic?

**Great for:**

- Modern web apps that need dark mode support
- Design systems that value accessibility
- Teams that want to move fast without sacrificing quality
- Projects using cutting-edge CSS features

**Not ideal for:**

- Legacy browsers (requires OKLCH and Relative Color Syntax)
- Marketing sites that need pixel-perfect brand matching (Axiomatic prioritizes accessibility over exact color reproduction)
- Projects that can't use alpha-stage tools ([see limitations](/alpha-limitations))

## Want to Understand the Theory?

The "how" is fascinating, but you don't need it to get started:

- **[Thinking in Surfaces](/concepts/thinking-in-surfaces)** - The mental model behind the system
- **[The Physics of Light](/concepts/physics-of-light)** - Why we use OKLCH and perceptual uniformity
- **[Accessibility First](/concepts/accessibility-first)** - How APCA works under the hood

---

## Configuration Schema

```json
{
  "$ref": "#/definitions/UserConfig",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ContrastOffsets": {
      "additionalProperties": false,
      "properties": {
        "dark": {
          "type": "number"
        },
        "light": {
          "type": "number"
        }
      },
      "type": "object"
    },
    "DeepPartial<AnchorValue>": {
      "additionalProperties": false,
      "properties": {
        "adjustable": {
          "type": "boolean"
        },
        "background": {
          "$ref": "#/definitions/DeepPartial%3Cnumber%3E"
        }
      },
      "type": "object"
    },
    "DeepPartial<Anchors>": {
      "additionalProperties": false,
      "properties": {
        "dark": {
          "$ref": "#/definitions/DeepPartial%3CModeAnchors%3E"
        },
        "light": {
          "$ref": "#/definitions/DeepPartial%3CModeAnchors%3E"
        }
      },
      "type": "object"
    },
    "DeepPartial<BezierCurve>": {
      "additionalProperties": false,
      "properties": {
        "p1": {
          "$ref": "#/definitions/DeepPartial%3C%5Bnumber%2Cnumber%5D%3E"
        },
        "p2": {
          "$ref": "#/definitions/DeepPartial%3C%5Bnumber%2Cnumber%5D%3E"
        }
      },
      "type": "object"
    },
    "DeepPartial<ModeAnchors>": {
      "additionalProperties": false,
      "properties": {
        "end": {
          "$ref": "#/definitions/DeepPartial%3CAnchorValue%3E"
        },
        "start": {
          "$ref": "#/definitions/DeepPartial%3CAnchorValue%3E"
        }
      },
      "type": "object"
    },
    "DeepPartial<PolarityAnchors>": {
      "additionalProperties": false,
      "properties": {
        "inverted": {
          "$ref": "#/definitions/DeepPartial%3CAnchors%3E"
        },
        "keyColors": {
          "$ref": "#/definitions/DeepPartial%3Cindexed-type-1474508258-74242-74263-1474508258-74138-74264-1474508258-0-218439%3Cstring%2Cstring%3E1922313925%3E"
        },
        "page": {
          "$ref": "#/definitions/DeepPartial%3CAnchors%3E"
        }
      },
      "type": "object"
    },
    "DeepPartial<[number,number]>": {
      "items": {
        "type": [
          "number"
        ]
      },
      "type": "array"
    },
    "DeepPartial<def-alias-src_lib_types.ts-2498-2729-src_lib_types.ts-0-6101[]>": {
      "items": {
        "additionalProperties": false,
        "properties": {
          "gapBefore": {
            "description": "Extra spacing (in contrast steps) before this group starts. Used to create visual separation between groups.",
            "type": "number"
          },
          "name": {
            "type": "string"
          },
          "surfaces": {
            "items": {
              "$ref": "#/definitions/SurfaceConfig"
            },
            "type": "array"
          }
        },
        "required": [
          "name",
          "surfaces"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "DeepPartial<def-alias-src_lib_types.ts-2729-2809-src_lib_types.ts-0-6101355102109>": {
      "additionalProperties": false,
      "properties": {
        "p1": {
          "$ref": "#/definitions/DeepPartial%3C%5Bnumber%2Cnumber%5D%3E"
        },
        "p2": {
          "$ref": "#/definitions/DeepPartial%3C%5Bnumber%2Cnumber%5D%3E"
        }
      },
      "type": "object"
    },
    "DeepPartial<indexed-type-1474508258-74242-74263-1474508258-74138-74264-1474508258-0-218439<string,string>1922313925>": {
      "additionalProperties": {
        "$ref": "#/definitions/DeepPartial%3Cstring%3E"
      },
      "type": "object"
    },
    "DeepPartial<number1805728063>": {
      "description": "Maximum hue rotation in degrees.",
      "type": "number"
    },
    "DeepPartial<number1808058353>": {
      "description": "Number of sizes to generate (e.g. 5 for xs, sm, base, lg, xl).",
      "type": "number"
    },
    "DeepPartial<number524178369>": {
      "description": "Base size in rem (e.g. 0.75).",
      "type": "number"
    },
    "DeepPartial<number686710375>": {
      "description": "Max size in rem (e.g. 3.0).",
      "type": "number"
    },
    "DeepPartial<number>": {
      "type": "number"
    },
    "DeepPartial<string>": {
      "type": "string"
    },
    "ModeSpec": {
      "additionalProperties": false,
      "properties": {
        "background": {
          "type": "number"
        },
        "debug": {
          "additionalProperties": false,
          "properties": {
            "clamped": {
              "type": "boolean"
            },
            "targetContrast": {
              "type": "number"
            }
          },
          "required": [
            "targetContrast",
            "clamped"
          ],
          "type": "object"
        },
        "fg-baseline": {
          "type": "number"
        },
        "fg-baseline-hc": {
          "type": "number"
        },
        "fg-high": {
          "type": "number"
        },
        "fg-high-hc": {
          "type": "number"
        },
        "fg-strong": {
          "type": "number"
        },
        "fg-strong-hc": {
          "type": "number"
        },
        "fg-subtle": {
          "type": "number"
        },
        "fg-subtle-hc": {
          "type": "number"
        },
        "fg-subtlest": {
          "type": "number"
        },
        "fg-subtlest-hc": {
          "type": "number"
        }
      },
      "required": [
        "background",
        "fg-high",
        "fg-strong",
        "fg-baseline",
        "fg-subtle",
        "fg-subtlest",
        "fg-high-hc",
        "fg-strong-hc",
        "fg-baseline-hc",
        "fg-subtle-hc",
        "fg-subtlest-hc"
      ],
      "type": "object"
    },
    "Polarity": {
      "enum": [
        "page",
        "inverted"
      ],
      "type": "string"
    },
    "StateDefinition": {
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string"
        },
        "offset": {
          "description": "Contrast offset relative to the parent surface. Positive = more contrast against text (lighter in light mode, darker in dark mode).",
          "type": "number"
        }
      },
      "required": [
        "name",
        "offset"
      ],
      "type": "object"
    },
    "SurfaceConfig": {
      "additionalProperties": false,
      "properties": {
        "computed": {
          "additionalProperties": false,
          "properties": {
            "dark": {
              "$ref": "#/definitions/ModeSpec"
            },
            "light": {
              "$ref": "#/definitions/ModeSpec"
            }
          },
          "required": [
            "light",
            "dark"
          ],
          "type": "object"
        },
        "contrastOffset": {
          "$ref": "#/definitions/ContrastOffsets",
          "description": "Shifts the surface's target contrast relative to its position in the sequence."
        },
        "description": {
          "type": "string"
        },
        "hue": {
          "description": "Target hue for this surface. Can be a number (0-360) or a reference to a key color (e.g. \"brand\").",
          "type": [
            "number",
            "string"
          ]
        },
        "label": {
          "type": "string"
        },
        "override": {
          "additionalProperties": false,
          "description": "Manual hex override for the surface background color. If set, the solver will use this color instead of the calculated one.",
          "properties": {
            "dark": {
              "type": "string"
            },
            "light": {
              "type": "string"
            }
          },
          "type": "object"
        },
        "polarity": {
          "$ref": "#/definitions/Polarity"
        },
        "slug": {
          "type": "string"
        },
        "states": {
          "description": "Derivative surfaces (states) that are solved relative to this surface.",
          "items": {
            "$ref": "#/definitions/StateDefinition"
          },
          "type": "array"
        },
        "targetChroma": {
          "description": "Target chroma for this surface. If set, the solver will adjust Lightness to compensate for the HK effect.",
          "type": "number"
        }
      },
      "required": [
        "slug",
        "label",
        "polarity"
      ],
      "type": "object"
    },
    "UserConfig": {
      "additionalProperties": false,
      "properties": {
        "$schema": {
          "type": "string"
        },
        "anchors": {
          "$ref": "#/definitions/DeepPartial%3CPolarityAnchors%3E"
        },
        "borderTargets": {
          "additionalProperties": false,
          "properties": {
            "critical": {
              "$ref": "#/definitions/DeepPartial%3Cnumber%3E"
            },
            "decorative": {
              "$ref": "#/definitions/DeepPartial%3Cnumber%3E"
            },
            "interactive": {
              "$ref": "#/definitions/DeepPartial%3Cnumber%3E"
            }
          },
          "type": "object"
        },
        "groups": {
          "$ref": "#/definitions/DeepPartial%3Cdef-alias-src_lib_types.ts-2498-2729-src_lib_types.ts-0-6101%5B%5D%3E"
        },
        "hueShift": {
          "additionalProperties": false,
          "properties": {
            "curve": {
              "$ref": "#/definitions/DeepPartial%3CBezierCurve%3E"
            },
            "maxRotation": {
              "$ref": "#/definitions/DeepPartial%3Cnumber1805728063%3E"
            }
          },
          "type": "object"
        },
        "options": {
          "additionalProperties": false,
          "properties": {
            "prefix": {
              "type": "string"
            },
            "selector": {
              "type": "string"
            }
          },
          "type": "object"
        },
        "palette": {
          "additionalProperties": false,
          "properties": {
            "hues": {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            "targetChroma": {
              "type": "number"
            },
            "targetContrast": {
              "type": "number"
            }
          },
          "type": "object"
        },
        "presets": {
          "additionalProperties": false,
          "properties": {
            "typography": {
              "additionalProperties": false,
              "properties": {
                "fonts": {
                  "additionalProperties": {
                    "$ref": "#/definitions/DeepPartial%3Cstring%3E"
                  },
                  "type": "object"
                },
                "scale": {
                  "additionalProperties": false,
                  "properties": {
                    "curve": {
                      "$ref": "#/definitions/DeepPartial%3Cdef-alias-src_lib_types.ts-2729-2809-src_lib_types.ts-0-6101355102109%3E"
                    },
                    "maxSize": {
                      "$ref": "#/definitions/DeepPartial%3Cnumber686710375%3E"
                    },
                    "minSize": {
                      "$ref": "#/definitions/DeepPartial%3Cnumber524178369%3E"
                    },
                    "steps": {
                      "$ref": "#/definitions/DeepPartial%3Cnumber1808058353%3E"
                    }
                  },
                  "type": "object"
                },
                "sizes": {
                  "additionalProperties": {
                    "$ref": "#/definitions/DeepPartial%3Cstring%3E"
                  },
                  "type": "object"
                },
                "weights": {
                  "additionalProperties": {
                    "$ref": "#/definitions/DeepPartial%3Cnumber%3E"
                  },
                  "type": "object"
                }
              },
              "type": "object"
            }
          },
          "type": "object"
        },
        "vibe": {
          "$ref": "#/definitions/VibeName"
        }
      },
      "type": "object"
    },
    "VibeName": {
      "type": [
        "string"
      ]
    }
  }
}
```

