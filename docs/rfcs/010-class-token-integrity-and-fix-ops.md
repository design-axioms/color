# RFC 010: Class-Token Integrity, Safe Fixes, and Demo Enforcement

**Status**: Proposed  
**Date**: 2025-12-13  
**Author**: GitHub Copilot (GPT-5.2 Preview)

## Summary

This RFC formalizes a non-negotiable constraint for the Axiomatic Color System:

- **All authored styling that implies color must be expressed via class-based tokens provided by the library** (e.g. `surface-*`, `text-*`, `hue-*`, and other library-provided, color-affecting utilities like `bordered`, `shadow-*`).
- Authored code must **not** hardcode colors **and must not** reference `--axm*` / `--_axm*` variables directly.

It also defines the correct architecture for “apply fix” behavior in the inspector:

- “Apply fix” is **safe-only** (inline styles + utility classes + adding validated token classes).
- For rule-driven mismatches, the inspector must produce **copyable instructions** rather than attempting runtime overrides.

Finally, it defines enforcement mechanisms for the Vercel demo:

- The demo must be implemented **only through public, documented APIs/commands**.
- The demo must obey “class-token integrity”.
- CI must fail when the demo diverges from user-model-derived artifacts or when it violates the token/variable/color constraints.

**Update (Policy-as-data)**: This RFC also defines the _mechanism_ for class-token integrity:

- Enforcement is **per-config strict**: each consumer surface (docs site, demo) is validated against the token set emitted by the solver for that surface’s configuration.
- The solver emits a **class-token manifest** that is the canonical allowlist for that configuration.
- Tooling (including editor completions) must consume **solver-emitted** manifests; editor tooling is not an authority.

## Consumer Contract (What This RFC Is Really Enforcing)

This RFC is not just “no hardcoded colors”. It is a stricter architectural constraint:

**Consumer code must not address the color engine directly.**

Instead, consumer code must express _intent_ only through the library’s public semantic interface:

- **Library-provided class tokens** (per-config allowlisted): `surface-*`, `text-*`, `hue-*`, plus other library utilities that imply color (e.g. `bordered`, `shadow-*`).
- **Documented JS APIs/commands** (never raw CSS variable reads/writes).

### What “Addressing the Engine” Means (Forbidden)

Any authored styling that uses the variable plumbing as a styling API is forbidden, including:

- Using semantic tokens as direct outputs: `background: var(--axm-surface-token)`
- Using private plumbing as direct outputs: `color: var(--_axm-computed-fg-color)`
- Using legacy/un-namespaced leftovers as direct outputs: `border-color: var(--computed-border-dec-color)`

Rationale: once consumers read/write engine variables directly, the system becomes un-auditable and non-deterministic. The unit of styling must remain the policy-token (class), not an ad-hoc property assignment.

### Exception: Integration Adapters (Theme-System Boundaries)

Some markup is not controlled by us (e.g. Starlight internals, vendor component libraries). In those cases, we may need a narrowly-scoped _integration adapter_.

See RFC013 for the generalized “adapter + bridge exports” strategy.

Rule:

- Foreign theme variables (e.g. Starlight `--sl-*`) are permitted **only** inside an explicit adapter boundary.

Starlight adapter boundary in this repo:

- `--sl-*` usage is permitted **only** in the dedicated Starlight bridge stylesheet:
  - `site/src/styles/starlight-custom.css` (bridge stylesheet that targets Starlight-owned markup and maps Starlight palette vars to Axiomatic bridge exports).
- `--sl-*` is forbidden everywhere else (authored components, site utilities, demo code).

Runtime integration notes:

- Runtime JS/TS/Astro may do **DOM wiring** (e.g. applying `surface-*` / `text-*` classes to vendor-owned markup) and may integrate with a **documented theme API** (e.g. `ThemeManager`).
- Runtime JS/TS/Astro must not reference foreign palette variables (e.g. `--sl-*`) and must not reference Axiomatic engine/bridge variables (e.g. `--axm-*`, `--_axm-*`).

This preserves a clean boundary: Starlight variables exist because Starlight owns the markup; they are not a general styling API.

## Motivation

The Axiomatic Color System’s algebra is strong, but **only works if consumers follow it**. Several recent issues demonstrate that the system can be undermined by:

- treating computed color values as token identifiers,
- bypassing the class-token pipeline by reading or setting variables directly,
- patching over mismatches via ad-hoc style overrides.

This RFC exists to:

1. **Make the algebra enforceable** in code, tests, and demos.
2. Prevent future regressions by ensuring invalid operations are not representable.
3. Clarify what “a correct demo” means (and how to mechanically check it).

## Glossary

- **Authored code**: application or demo code written by humans (JS/TS/TSX, CSS, Svelte, Astro, HTML). This excludes code generated by the Axiomatic toolchain.
- **Library-provided class token**: a class name whose semantics are defined by the library and whose effect is expressed through the algebra. Examples:
  - `surface-*` (surface intent)
  - `text-*` (text intent)
  - `hue-*` (accent/brand intent)
  - `bordered`, `shadow-*` (if they imply color, they must come from the library)
- **Computed value**: a resolved color string such as `oklch(...)`, `rgb(...)`, etc.
- **Consumer layer**: any usage site (docs, demo, app) that consumes the library.
- **Plumbing layer**: generated CSS internals, including variables like `--axm-*` and `--_axm-*`.

## Axioms (Hard Constraints)

### Axiom 1: Class-Token Integrity (Consumer Layer)

All **authored** styling that implies any color effects must be expressed using **library-provided class tokens**, never via computed values or direct variable references.

Allowed (consumer layer):

- Adding/removing library class tokens: `element.classList.add("surface-card")`.
- Authoring non-color tokens in the demo/site (layout, spacing, etc.) as local classes.

Forbidden (consumer layer):

- Hardcoded colors used as styling outputs:
  - `background-color: #0070f3;`
  - `color: oklch(...);`
  - `element.style.backgroundColor = "rgb(...)"`
- Direct variable usage for color outputs:
  - `background-color: var(--axm-surface-token)`
  - `background-color: var(--_axm-computed-surface)`
  - any `var(--axm-*)` / `var(--_axm-*)` used for authored styling

**Exception**: Brand color may be supplied as **solver input** (user model input) but must not be used as direct styling output.

### Axiom 1.1: Allowlist-Only, Per-Config Strict

When validating “class-token integrity”, the system must **not** rely on heuristics (“anything matching `surface-*` is a token”).

Instead:

- A consumer layer is validated against a **config-specific allowlist** emitted by the solver for that configuration.
- A class token that _looks_ like an Axiomatic token (reserved prefix like `surface-`, `text-`, `hue-`, etc.) but is not in the allowlist is an error.

Rationale:

- Prevents the “`oklch(...)` treated as a class token” failure mode.
- Prevents drift where consumers start inventing pseudo-tokens.
- Keeps the contract aligned with the user model: configs define the public surface.

### Axiom 2: Plumbing Variables Are Internal

Generated CSS is allowed to use variables as implementation detail.

However, consumer code must treat those variables as private and unstable. The only stable interface is:

- documented commands
- documented JS API
- class-token utilities

### Axiom 3: If Variables Are “Required”, Stop

If a desired feature appears to require reading/setting `--axm*` / `--_axm*` directly, implementation must **STOP** and escalate:

- either the feature is not aligned with the current algebra,
- or the algebra/model needs extension to express it via class tokens.

## Incident: What Went Wrong (Reference Failure)

A real failure occurred when clicking “Apply fix” in the inspector:

> `InvalidCharacterError: Failed to execute 'add' on 'DOMTokenList': The token provided ('oklch(1 0 0)') contains HTML space characters...`

Root cause:

- The inspector auto-fix treated an **expected surface value** (computed `oklch(...)`) as if it were a **token class name**.
- This indicates a type/representation flaw: the system mixed “value” and “token identifier”.

This RFC makes that mixture unrepresentable.

## Inspector: “Apply Fix” Semantics

### Principle

The inspector exists to restore adherence to the algebra. Therefore its fixes must be expressed only via class-token operations and removal of conflicting authored sources.

### “Apply Fix” is Safe-Only

The inspector’s “Apply fix” button is permitted to:

1. Add **validated library token classes** (no whitespace; must match the library token namespace).
2. Remove conflicting utility classes (e.g. `bg-*`, if used in the project).
3. Remove conflicting inline styles (e.g. inline `background-color`).

The inspector’s “Apply fix” button is **not** permitted to:

- set any style property to a value derived from plumbing variables (e.g. `background-color: var(--_axm-computed-surface)`),
- introduce any new authored color output,
- attempt to “win” against an authored stylesheet rule by injecting runtime overrides.

### Rule-Driven Mismatches (Copy Instructions Only)

If the mismatch is driven by a CSS rule (not inline and not utility classes), the inspector must:

- produce copyable instructions ("Remove `background-color` from selector X in file Y, then add class `surface-*`"),
- not attempt to auto-override.

Rationale: without modifying the authored stylesheet, there is no algebra-preserving, variable-free way to guarantee the rule is neutralized.

### Required Data Model Separation

To support this, violations must carry separate fields:

- **Expected/actual values**: computed colors used for diagnosis.
- **Recommended token class**: a class name that, if applied, expresses intent via the algebra.

The inspector must never attempt to apply computed values as if they were token identifiers.

## Refactor: Problems, Fixes, and Undo (Testable Abstractions)

### Goal

Make fixes deterministic, validated, and testable. Avoid centralized, ad-hoc fix logic.

### Objects

#### `Problem`

A `Problem` instance represents one actionable item in the audit UI.

Minimum shape:

- `id: string`
- `title: string`
- `details: string | StructuredDetails`
- `apply(ctx): UndoAction[]`

Optional:

- `canApply(ctx): boolean` (e.g. rule-driven mismatch is not auto-applicable)

#### `UndoAction`

Undo is an internal correctness mechanism.

Minimum shape:

- `description: string`
- `undo(ctx): void`

UI requirement: for now, the UI only needs **Clear all / Reset all**. The undo log is an internal stack to enable tests and future UX.

### Fix Operations (Strongly Typed)

Recommended approach: express `Problem.apply()` as a sequence of typed operations that each produce their own undo:

- `AddClassTokenOp` (validated)
- `RemoveClassTokenOp`
- `RemoveInlineStylePropertyOp`

Explicitly forbidden operations in consumer-layer fixes:

- `SetStyleToVariableOp("background-color", "var(--_axm-...)")`
- `SetComputedColorOp("background-color", "oklch(...)")`

### Validation Boundary

All class tokens applied by fixes must be validated:

- must not contain whitespace
- must belong to the library-provided token namespace (e.g. `surface-*`, `text-*`, `hue-*`, plus explicit allowlist for color-affecting library utilities)

If validation fails:

- the fix must not apply
- the UI must present a “copy instructions” path

## Vercel Demo: Correctness Contract

The Vercel demo must demonstrate the system by following the same constraints as real consumers.

### Demo Axioms

1. **Public interface only**: the demo must use only APIs and commands documented in the main documentation site.
2. **Class-token integrity**: all color effects in the demo UI must come from library-provided class tokens.
3. **Brand color** is allowed only as solver input, not direct styling output.

### Enforcement: Static Checks (Fail CI)

Introduce/enable a check that fails if demo-authored sources contain:

- `var(--axm-` or `var(--_axm-`
- literal authored color outputs (examples; exact patterns may be tuned):
  - `#(?:[0-9a-fA-F]{3,8})\b`
  - `\boklch\(`
  - `\brgb\(` / `\brgba\(` / `\bhsl\(`

Allowed exceptions must be explicit and narrow (e.g. a “solver input literal” may appear, but must not be assigned to styling properties).

Also enforce import boundaries:

- forbid direct imports from internal paths not documented as public API.

### Enforcement: Class-Token Allowlist (Per-Config)

Each shipped consumer surface must have an associated solver configuration.

- Docs site policy is derived from the docs site config.
- Demo policy is derived from the demo config.

CI must validate that any reserved-prefix class token used in shipped markup is present in the solver-emitted allowlist for that surface.

This check is independent of (and in addition to) the forbidden-variable and forbidden-literal checks.

Implementation note: the allowlist is expected to be committed as policy-as-data (generated deterministically).

### Enforcement: Artifact Equivalence (Fail CI)

Compare demo shipped artifacts against user-model-derived outputs:

- Generate artifacts using **documented** commands/APIs.
- Compare to committed/shipped demo artifacts.
- Fail with a diff when outputs diverge.

This ensures the demo is a faithful, reproducible projection of the user model.

## Testing Strategy

### Unit Tests (Inspector)

Add tests that verify:

- “Apply fix” never attempts `classList.add()` with whitespace-containing tokens.
- “Apply fix” refuses rule-driven mismatches (no runtime override).
- Safe fixes round-trip correctly via undo log (or via reset-all semantics).

### Integration Tests (Demo)

- CI check for forbidden patterns and forbidden imports.
- Artifact equivalence check.

### Tooling Integration (VS Code Extension)

The VS Code extension must **not** maintain an authoritative hand-curated token inventory.

Instead, it must consume token lists emitted by the solver.

Minimum acceptable implementation:

- Generate a committed token manifest from the solver (or deterministic policy-as-data derived from it).
- Generate the extension’s completion token list from that manifest.

Future improvement (optional): compute completions from the user’s local `color-config.json` in the workspace.

## Acceptance Criteria

This RFC is considered implemented when:

1. Clicking “Apply fix” never throws, including the observed `oklch(1 0 0)` incident.
2. “Apply fix” only modifies elements via:
   - adding/removing validated library class tokens
   - removing conflicting inline `background-color`
   - removing conflicting utility classes
3. The inspector never applies `var(--axm-*)` or `var(--_axm-*)` in consumer-layer overrides.
4. The Vercel demo contains no authored direct variable usage for colors and no authored hardcoded color outputs for styling.
5. Demo artifact equivalence check runs in CI and fails on divergence.
6. Enforcement validates reserved-prefix class tokens against a **per-config** solver-emitted allowlist.
7. Editor tooling token lists are generated from solver output (not hand-maintained).

## Non-Goals

- A full re-review of the algebra. That is a separate phase.
- A full interactive undo UI. A minimal “clear/reset all” UI is sufficient; undo is primarily for correctness and tests.

## Open Questions

- What is the canonical list of **reserved prefixes** for Axiomatic class tokens?
- Should enforcement validate _only_ reserved-prefix class tokens, or also enforce a stricter “no unknown classes inside these scopes” rule?
- What is the precise definition of "documented API" for import enforcement (package exports only vs. docs-annotated subset)?

## Appendix: Implementation Notes (Non-Normative)

- The inspector should derive “recommended surface class” from the token resolver (e.g. `responsibleClass`) rather than from computed color values.
- When a fix cannot be safely applied, the UI should present a deterministic instruction block that references selector + file (when known).
