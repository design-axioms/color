{"version":3,"sources":["../src/lib/generator.ts"],"names":[],"mappings":"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","file":"chunk-EB6GU2YN.js","sourcesContent":["import {\n  calculateHueShift,\n  solveBorderAlpha,\n  solveForegroundSpec,\n} from \"./math.ts\";\nimport type {\n  BorderTargets,\n  HueShiftConfig,\n  Mode,\n  SurfaceGroup,\n} from \"./types.ts\";\n\nexport function generateTokensCss(\n  groups: SurfaceGroup[],\n  backgrounds: Map<string, Record<Mode, number>>,\n  hueShiftConfig?: HueShiftConfig,\n  borderTargets?: BorderTargets,\n  selector?: string\n): string {\n  const rootLines: string[] = [];\n  const propertyLines: string[] = [];\n\n  rootLines.push(\"/* AUTO-GENERATED by src/lib/generator.ts */\");\n\n  // Note: We assume @property definitions are loaded via engine.css\n  // Re-declaring them here causes transition glitches in some browsers\n  // when the stylesheet is updated dynamically.\n\n  const toNumber = (n: number): number => parseFloat(n.toFixed(4));\n\n  for (const group of groups) {\n    for (const surface of group.surfaces) {\n      const bgLight = backgrounds.get(surface.slug)?.light ?? 0;\n      const bgDark = backgrounds.get(surface.slug)?.dark ?? 0;\n\n      const lightSpec = solveForegroundSpec(bgLight);\n      const darkSpec = solveForegroundSpec(bgDark);\n\n      const lightShift = calculateHueShift(bgLight, hueShiftConfig);\n      const darkShift = calculateHueShift(bgDark, hueShiftConfig);\n\n      // Generate the Class Definition\n      const prefix = selector ? `${selector} ` : \"\";\n      rootLines.push(`${prefix}.surface-${surface.slug} {`);\n\n      // 1. Surface Token\n      rootLines.push(\n        `  --surface-token: light-dark(\n    oklch(${toNumber(bgLight)} 0 ${toNumber(lightShift)}),\n    oklch(${toNumber(bgDark)} 0 ${toNumber(darkShift)})\n  );`\n      );\n\n      // 2. Text Tokens\n      rootLines.push(\n        `  --text-high-token: light-dark(\n    oklch(${toNumber(lightSpec[\"fg-high\"])} 0 0),\n    oklch(${toNumber(darkSpec[\"fg-high\"])} 0 0)\n  );`\n      );\n\n      rootLines.push(\n        `  --text-subtle-token: light-dark(\n    oklch(${toNumber(lightSpec[\"fg-subtle\"])} 0 0),\n    oklch(${toNumber(darkSpec[\"fg-subtle\"])} 0 0)\n  );`\n      );\n\n      rootLines.push(\n        `  --text-subtlest-token: light-dark(\n    oklch(${toNumber(lightSpec[\"fg-subtlest\"])} 0 0),\n    oklch(${toNumber(darkSpec[\"fg-subtlest\"])} 0 0)\n  );`\n      );\n\n      // 3. Border Tokens\n      if (borderTargets) {\n        const solveBorder = (\n          bgL: number,\n          textL: number,\n          target: number\n        ): number => solveBorderAlpha(bgL, textL, target);\n\n        const lightDec = solveBorder(\n          bgLight,\n          lightSpec[\"fg-strong\"],\n          borderTargets.decorative\n        );\n        const darkDec = solveBorder(\n          bgDark,\n          darkSpec[\"fg-strong\"],\n          borderTargets.decorative\n        );\n        const lightInt = solveBorder(\n          bgLight,\n          lightSpec[\"fg-strong\"],\n          borderTargets.interactive\n        );\n        const darkInt = solveBorder(\n          bgDark,\n          darkSpec[\"fg-strong\"],\n          borderTargets.interactive\n        );\n\n        const lightBorderL = lightSpec[\"fg-strong\"];\n        const darkBorderL = darkSpec[\"fg-strong\"];\n\n        rootLines.push(\n          `  --border-dec-token: light-dark(\n    oklch(${toNumber(lightBorderL)} 0 0 / ${toNumber(lightDec)}),\n    oklch(${toNumber(darkBorderL)} 0 0 / ${toNumber(darkDec)})\n  );`\n        );\n\n        rootLines.push(\n          `  --border-int-token: light-dark(\n    oklch(${toNumber(lightBorderL)} 0 0 / ${toNumber(lightInt)}),\n    oklch(${toNumber(darkBorderL)} 0 0 / ${toNumber(darkInt)})\n  );`\n        );\n      }\n\n      rootLines.push(`}`); // End class\n\n      // States (Hover/Active)\n      if (surface.states) {\n        surface.states.forEach((state) => {\n          const stateSlug = `${surface.slug}-${state.name}`;\n          const bgState = backgrounds.get(stateSlug);\n\n          if (bgState) {\n            // We generate a modifier class? Or pseudo-class?\n            // The config says \"states: [{name: 'hover'}]\".\n            // Usually this maps to `.surface-card:hover`.\n            // But sometimes it might be a class `.surface-card-selected`.\n            // Let's assume pseudo-classes for standard names, and classes for others?\n            // The original code generated `--surface-card-hover-token`.\n            // And `utilities.css` mapped `.surface-card:hover` to that token.\n\n            // Here we can generate:\n            // .surface-card:hover { --surface-token: ... }\n\n            const stateSelector =\n              state.name === \"hover\" || state.name === \"active\"\n                ? `.surface-${surface.slug}:${state.name}`\n                : `.surface-${surface.slug}-${state.name}`; // e.g. .surface-card-selected\n\n            const lightStateShift = calculateHueShift(\n              bgState.light,\n              hueShiftConfig\n            );\n            const darkStateShift = calculateHueShift(\n              bgState.dark,\n              hueShiftConfig\n            );\n\n            rootLines.push(`${prefix}${stateSelector} {`);\n            rootLines.push(\n              `  --surface-token: light-dark(\n    oklch(${toNumber(bgState.light)} 0 ${toNumber(lightStateShift)}),\n    oklch(${toNumber(bgState.dark)} 0 ${toNumber(darkStateShift)})\n  );`\n            );\n            rootLines.push(`}`);\n          }\n        });\n      }\n      rootLines.push(\"\");\n    }\n  }\n\n  return [...propertyLines, \"\", ...rootLines].join(\"\\n\");\n}\n"]}