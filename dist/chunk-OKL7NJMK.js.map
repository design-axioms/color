{"version":3,"sources":["../src/lib/index.ts"],"names":["lightness"],"mappings":"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","file":"chunk-OKL7NJMK.js","sourcesContent":["import { converter } from \"culori\";\nimport {\n  avg,\n  backgroundBounds,\n  clamp01,\n  clampTo,\n  contrastForBackground,\n  roundLightness,\n  solveBackgroundForContrast,\n  solveForegroundSpec,\n} from \"./math.ts\";\nimport type {\n  Anchors,\n  Context,\n  Mode,\n  ModeAnchors,\n  ModeSpec,\n  Mutable,\n  PolarityAnchors,\n  SolverConfig,\n  SurfaceConfig,\n  SurfaceGroup,\n} from \"./types.ts\";\nexport * from \"./constants.ts\";\n\nconst toOklch = converter(\"oklch\");\n\nexport function getKeyColorStats(keyColors?: Record<string, string>): {\n  lightness?: number;\n  chroma?: number;\n  hue?: number;\n} {\n  if (!keyColors) {\n    return {};\n  }\n\n  const lightnesses: number[] = [];\n  const chromas: number[] = [];\n  const hues: number[] = [];\n\n  for (const value of Object.values(keyColors)) {\n    const entry = toOklch(value) as\n      | { l: number; c: number; h: number }\n      | undefined;\n\n    if (entry) {\n      lightnesses.push(entry.l);\n      chromas.push(entry.c);\n      if (!isNaN(entry.h)) {\n        hues.push(entry.h);\n      }\n    }\n  }\n\n  if (lightnesses.length === 0) {\n    return {};\n  }\n\n  return {\n    lightness: roundLightness(avg(lightnesses)),\n    chroma: parseFloat(avg(chromas).toFixed(4)),\n    hue: hues.length > 0 ? parseFloat(avg(hues).toFixed(4)) : undefined,\n  };\n}\n\nfunction computeKeyColorLightness(\n  keyColors?: Record<string, string>\n): number | undefined {\n  if (!keyColors) {\n    return undefined;\n  }\n\n  const lightnesses: number[] = [];\n\n  for (const value of Object.values(keyColors)) {\n    const entry = toOklch(value) as { l: number } | undefined;\n\n    if (entry) {\n      lightnesses.push(entry.l);\n    }\n  }\n\n  if (lightnesses.length === 0) {\n    return undefined;\n  }\n\n  return roundLightness(avg(lightnesses));\n}\n\nfunction alignInvertedAnchors(\n  anchors: PolarityAnchors,\n  keyColors?: Record<string, string>\n): void {\n  const keyColorLightness = computeKeyColorLightness(keyColors);\n\n  if (keyColorLightness !== undefined) {\n    const invertedAnchors = anchors.inverted;\n\n    const updateEnd = (\n      modeAnchors: ModeAnchors,\n      lightness: number\n    ): ModeAnchors => ({\n      ...modeAnchors,\n      end: { ...modeAnchors.end, background: lightness },\n    });\n\n    const lightness = clamp01(keyColorLightness);\n\n    const newInverted: Anchors = {\n      light: updateEnd(invertedAnchors.light, lightness),\n      dark: updateEnd(invertedAnchors.dark, lightness),\n    };\n\n    (anchors as Mutable<PolarityAnchors>).inverted = newInverted;\n  }\n}\n\nfunction computeDeltaInfo(\n  context: Context,\n  anchors: ModeAnchors,\n  count: number\n): {\n  startBackground: number;\n  endBackground: number;\n  startContrast: number;\n  endContrast: number;\n  delta: number;\n} {\n  const startBackground = anchors.start.background;\n  const endBackground = anchors.end.background;\n  const startContrast = contrastForBackground(context, startBackground);\n  const endContrast = contrastForBackground(context, endBackground);\n  const delta = count <= 1 ? 0 : (endContrast - startContrast) / (count - 1);\n\n  return {\n    startBackground,\n    endBackground,\n    startContrast,\n    endContrast,\n    delta,\n  };\n}\n\nfunction solveBackgroundSequence(\n  context: Context,\n  anchors: ModeAnchors,\n  groups: SurfaceGroup[]\n): Map<string, number> {\n  const backgrounds = new Map<string, number>();\n  const { mode } = context;\n\n  if (groups.length === 0) return backgrounds;\n\n  const totalGroups = groups.length;\n  const deltaInfo = computeDeltaInfo(context, anchors, totalGroups);\n\n  const [minBg, maxBg] = backgroundBounds(\n    anchors.start.background,\n    anchors.end.background\n  );\n  const minContrast = Math.min(deltaInfo.startContrast, deltaInfo.endContrast);\n  const maxContrast = Math.max(deltaInfo.startContrast, deltaInfo.endContrast);\n\n  groups.forEach((group, groupIndex) => {\n    const gap = group.gapBefore ?? 0;\n    const adjustedGroupIndex = groupIndex + gap;\n\n    const groupBaseContrast =\n      deltaInfo.startContrast + deltaInfo.delta * adjustedGroupIndex;\n\n    group.surfaces.forEach((surface, surfaceIndex) => {\n      const intraGroupStep = deltaInfo.delta * 0.2;\n      const stagger = surfaceIndex * intraGroupStep;\n\n      const offset = surface.contrastOffset?.[mode] ?? 0;\n      const targetContrast = groupBaseContrast + stagger + offset;\n\n      const clampedContrast = clampTo(targetContrast, minContrast, maxContrast);\n\n      const solvedL = solveBackgroundForContrast(\n        context,\n        clampedContrast,\n        minBg,\n        maxBg\n      );\n\n      backgrounds.set(surface.slug, solvedL);\n\n      if (surface.states) {\n        surface.states.forEach((state) => {\n          const stateTarget = clampedContrast + state.offset;\n\n          const stateL = solveBackgroundForContrast(\n            context,\n            stateTarget,\n            minBg,\n            maxBg\n          );\n\n          backgrounds.set(`${surface.slug}-${state.name}`, stateL);\n        });\n      }\n    });\n  });\n\n  return backgrounds;\n}\n\nexport function solve(config: SolverConfig): {\n  surfaces: SurfaceConfig[];\n  backgrounds: Map<string, Record<Mode, number>>;\n} {\n  const anchors = config.anchors;\n  const groups = config.groups;\n  const allSurfaces = groups.flatMap((g) => g.surfaces);\n\n  alignInvertedAnchors(anchors, anchors.keyColors);\n\n  const backgrounds = new Map<string, { light: number; dark: number }>();\n\n  for (const polarity of [\"page\", \"inverted\"] as const) {\n    for (const mode of [\"light\", \"dark\"] as const) {\n      const relevantGroups = groups.filter((g) =>\n        g.surfaces.some((s) => s.polarity === polarity)\n      );\n\n      const filteredGroups = relevantGroups\n        .map((g) => ({\n          ...g,\n          surfaces: g.surfaces.filter((s) => s.polarity === polarity),\n        }))\n        .filter((g) => g.surfaces.length > 0);\n\n      const sequence = solveBackgroundSequence(\n        { polarity, mode },\n        anchors[polarity][mode],\n        filteredGroups\n      );\n\n      for (const [slug, value] of sequence.entries()) {\n        const entry = backgrounds.get(slug) ?? { light: 0, dark: 0 };\n        entry[mode] = value;\n        backgrounds.set(slug, entry);\n      }\n    }\n  }\n\n  const solvedSurfaces = allSurfaces.map((surface) => {\n    const background = backgrounds.get(surface.slug);\n\n    if (!background) {\n      throw new Error(`Missing solved backgrounds for ${surface.slug}.`);\n    }\n\n    const computed: Record<Mode, ModeSpec> = {\n      light: solveForegroundSpec(background.light),\n      dark: solveForegroundSpec(background.dark),\n    };\n\n    return { ...surface, computed };\n  });\n\n  return {\n    surfaces: solvedSurfaces,\n    backgrounds: backgrounds,\n  };\n}\n"]}