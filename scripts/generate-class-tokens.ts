/**
 * Generates solver-derived class-token allowlists.
 *
 * RFC 010 policy:
 * - Enforcement is per-config strict.
 * - The solver is the authority for what tokens exist.
 * - Tooling (including the VS Code extension) must consume solver-emitted lists
 *   rather than maintaining a separate authoritative inventory.
 *
 * Outputs (committed policy-as-data):
 * - policy/class-tokens.default.json
 * - policy/class-tokens.site.json
 * - policy/class-tokens.vercel-demo.json
 * - policy/class-tokens.json (back-compat union; not the primary enforcement source)
 *
 * Also updates:
 * - packages/vscode-extension/src/generated/tokens.ts
 */

import fs from "node:fs";
import path from "node:path";

import {
  DEFAULT_CONFIG,
  resolveConfig,
  solve,
  generateTokensCss,
} from "../src/lib/index.ts";

type ClassTokenPolicy = {
  schemaVersion: 1;
  sources: string[];
  reservedPrefixes: string[];
  classTokens: string[];
};

const ROOT = process.cwd();

const POLICY_DIR = path.join(ROOT, "policy");
const OUTPUT_DEFAULT_PATH = path.join(POLICY_DIR, "class-tokens.default.json");
const OUTPUT_SITE_PATH = path.join(POLICY_DIR, "class-tokens.site.json");
const OUTPUT_VERCEL_DEMO_PATH = path.join(
  POLICY_DIR,
  "class-tokens.vercel-demo.json",
);
const OUTPUT_UNION_PATH = path.join(POLICY_DIR, "class-tokens.json");

const VSCODE_EXTENSION_GENERATED_TOKENS_PATH = path.join(
  ROOT,
  "packages",
  "vscode-extension",
  "src",
  "generated",
  "tokens.ts",
);

const CONFIG_SOURCES: Array<{
  label: string;
  filePath?: string;
  config?: unknown;
  outputPath: string;
}> = [
  {
    label: "DEFAULT_CONFIG",
    config: DEFAULT_CONFIG,
    outputPath: OUTPUT_DEFAULT_PATH,
  },
  {
    label: "color-config.json",
    filePath: path.join(ROOT, "color-config.json"),
    outputPath: OUTPUT_SITE_PATH,
  },
  {
    label: "examples/vercel-demo/color-config.json",
    filePath: path.join(ROOT, "examples", "vercel-demo", "color-config.json"),
    outputPath: OUTPUT_VERCEL_DEMO_PATH,
  },
];

const ENGINE_CSS_PATH = path.join(ROOT, "css", "engine.css");

function isRecord(value: unknown): value is Record<string, unknown> {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}

function looksLikeUserConfig(value: unknown): boolean {
  if (!isRecord(value)) return false;
  // Heuristic: the solver config always has groups + anchors.
  return Array.isArray(value.groups) && isRecord(value.anchors);
}

function extractCssClassTokens(css: string): Set<string> {
  // Conservative class extractor: grabs `.foo-bar_baz` portions from selectors.
  const tokens = new Set<string>();
  const re = /(^|[^a-zA-Z0-9_-])\.([a-zA-Z_][a-zA-Z0-9_-]*)/g;

  let match: RegExpExecArray | null;
  while ((match = re.exec(css)) !== null) {
    const token = match[2];
    if (token) tokens.add(token);
  }

  return tokens;
}

function readEngineClassTokens(): Set<string> {
  if (!fs.existsSync(ENGINE_CSS_PATH)) {
    throw new Error(
      `Missing ${ENGINE_CSS_PATH}. This repo expects css/engine.css to exist.`,
    );
  }
  return extractCssClassTokens(fs.readFileSync(ENGINE_CSS_PATH, "utf8"));
}

function readJsonFile(filePath: string): unknown {
  const content = fs.readFileSync(filePath, "utf8");
  return JSON.parse(content);
}

// Prefix namespaces that are reserved for Axiomatic tokens.
// We intentionally do NOT reserve unrelated namespaces like `font-*`.
const RESERVED_PREFIXES = [
  "surface",
  "text",
  "hue",
  "bg",
  "border",
  "shadow",
  "fg",
  "preset",
];

function writePolicyFile(outputPath: string, policy: ClassTokenPolicy): void {
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, JSON.stringify(policy, null, 2) + "\n", "utf8");
}

function writeVscodeExtensionTokens(tokens: string[]): void {
  const header = `// This file is generated by scripts/generate-class-tokens.ts\n`;
  const body = `export const TOKENS = ${JSON.stringify(tokens, null, 2)} as const;\n`;
  fs.mkdirSync(path.dirname(VSCODE_EXTENSION_GENERATED_TOKENS_PATH), {
    recursive: true,
  });
  fs.writeFileSync(
    VSCODE_EXTENSION_GENERATED_TOKENS_PATH,
    header + body,
    "utf8",
  );
}

function main(): void {
  const engineTokens = readEngineClassTokens();

  const unionTokens = new Set<string>();
  const unionSources: string[] = [];

  const perConfigPolicies: Array<{
    outputPath: string;
    policy: ClassTokenPolicy;
  }> = [];

  for (const source of CONFIG_SOURCES) {
    unionSources.push(source.label);

    const rawConfig = source.filePath
      ? readJsonFile(source.filePath)
      : source.config;
    if (!looksLikeUserConfig(rawConfig)) {
      throw new Error(
        `Config source '${source.label}' does not look like a Solver UserConfig.`,
      );
    }

    // `resolveConfig` fills in defaults, so partial JSON is OK.
    // We cast because the runtime expects a Partial<SolverConfig>.
    const resolved = resolveConfig(rawConfig as any);

    // Important: derive class tokens from the same pipeline as `axiomatic build`.
    // `generateTheme()` is intended for runtime injection and is not guaranteed to
    // stay in lockstep with the CLI build output.
    const theme = solve(resolved);
    const css = generateTokensCss(
      resolved.groups,
      theme,
      resolved.borderTargets,
      resolved.options,
      resolved.anchors.keyColors,
      resolved.presets,
    );

    const configTokens = extractCssClassTokens(css);

    // Each consumer surface has access to the engine utilities plus the
    // solver-generated theme tokens.
    const allowedTokens = new Set<string>([...engineTokens, ...configTokens]);

    for (const token of allowedTokens) {
      unionTokens.add(token);
    }

    const policy: ClassTokenPolicy = {
      schemaVersion: 1,
      sources: ["css/engine.css", source.label],
      reservedPrefixes: RESERVED_PREFIXES,
      classTokens: [...allowedTokens].sort(),
    };

    perConfigPolicies.push({ outputPath: source.outputPath, policy });
  }

  // Write per-config policies (enforcement uses these).
  for (const { outputPath, policy } of perConfigPolicies) {
    writePolicyFile(outputPath, policy);
    console.log(
      `Wrote ${policy.classTokens.length} class tokens to ${outputPath}`,
    );
  }

  // Write union (back-compat + convenience; not the primary enforcement source).
  const unionPolicy: ClassTokenPolicy = {
    schemaVersion: 1,
    sources: ["css/engine.css", ...unionSources],
    reservedPrefixes: RESERVED_PREFIXES,
    classTokens: [...unionTokens].sort(),
  };
  writePolicyFile(OUTPUT_UNION_PATH, unionPolicy);
  console.log(
    `Wrote ${unionPolicy.classTokens.length} class tokens to ${OUTPUT_UNION_PATH}`,
  );

  // VS Code extension consumes solver-derived tokens (not authoritative).
  // For now, we use DEFAULT_CONFIG as the baseline completion set.
  const defaultPolicy = perConfigPolicies.find((p) =>
    p.outputPath.endsWith("class-tokens.default.json"),
  );
  if (!defaultPolicy) {
    throw new Error("Missing default class-token policy (unexpected).");
  }
  writeVscodeExtensionTokens(defaultPolicy.policy.classTokens);
  console.log(
    `Updated VS Code extension token completions at ${VSCODE_EXTENSION_GENERATED_TOKENS_PATH}`,
  );
}

main();
