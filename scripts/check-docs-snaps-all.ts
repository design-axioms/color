/**
 * Systematically run the transition-time snaps check across every docs route.
 *
 * Route source of truth: `site/dist` (generated by `pnpm --filter site build`).
 */

import { spawnSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";

type Options = {
  build: boolean;
  limit: number | null;
  only: string | null;
  withInspector: boolean;
  snaps: boolean;
};

function parseArgs(argv: string[]): Options {
  const opts: Options = {
    build: true,
    limit: null,
    only: null,
    withInspector: false,
    snaps: true,
  };

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    const next = argv[i + 1];

    if (!arg) continue;

    // Some pnpm invocation forms can forward a literal `--`.
    // Treat it as an argument separator.
    if (arg === "--") continue;

    if (arg === "--no-build") {
      opts.build = false;
      continue;
    }

    if (arg === "--limit") {
      if (!next) throw new Error("--limit requires a value");
      const parsed = Number.parseInt(next, 10);
      if (!Number.isFinite(parsed) || parsed < 0) {
        throw new Error(`Invalid --limit: ${next}`);
      }
      opts.limit = parsed;
      i += 1;
      continue;
    }

    if (arg === "--only") {
      if (!next) throw new Error("--only requires a value");
      opts.only = next;
      i += 1;
      continue;
    }

    if (arg === "--with-inspector") {
      opts.withInspector = true;
      continue;
    }

    if (arg === "--no-snaps") {
      opts.snaps = false;
      continue;
    }

    throw new Error(`Unknown arg: ${arg}`);
  }

  return opts;
}

function run(cmd: string, args: string[], opts?: { quiet?: boolean }) {
  const res = spawnSync(cmd, args, {
    cwd: process.cwd(),
    encoding: "utf8",
    stdio: opts?.quiet ? "pipe" : "inherit",
  });

  return {
    ok: res.status === 0,
    status: res.status ?? 1,
    stdout: res.stdout ?? "",
    stderr: res.stderr ?? "",
  };
}

function loadRoutes(): string[] {
  const result = run(
    process.execPath,
    ["scripts/list-astro-pages.ts", "--dist", "site/dist", "--format", "json"],
    { quiet: true },
  );

  if (!result.ok) {
    throw new Error(
      `Failed to list routes from site/dist.\n${result.stderr || result.stdout}`,
    );
  }

  const parsed = JSON.parse(result.stdout) as unknown;
  if (!Array.isArray(parsed) || !parsed.every((v) => typeof v === "string")) {
    throw new Error("Route list script returned invalid JSON");
  }

  // Filter to *docs* pages (Starlight content route + homepage).
  // Skip non-doc utility pages.
  return (parsed as string[]).filter(
    (r) => r !== "/404" && r !== "/hud/" && r !== "/studio/",
  );
}

function routeSlug(route: string): string {
  if (route === "/") return "root";
  return route.replace(/^\//, "").replace(/\/$/, "").replace(/\//g, "__");
}

async function main(): Promise<void> {
  const opts = parseArgs(process.argv.slice(2));

  if (opts.build) {
    const built = run("pnpm", ["--filter", "site", "build"]);
    if (!built.ok) {
      process.exitCode = built.status;
      return;
    }
  } else {
    const distPath = path.join(process.cwd(), "site", "dist");
    if (!fs.existsSync(distPath)) {
      throw new Error(
        "Missing site/dist. Run `pnpm --filter site build` or omit --no-build.",
      );
    }
  }

  const routesAll = loadRoutes();
  const routes =
    opts.only !== null
      ? routesAll.filter((r) => r === opts.only)
      : opts.limit === null
        ? routesAll
        : routesAll.slice(0, Math.max(0, opts.limit));

  if (routes.length === 0) {
    console.error("No routes selected.");
    process.exitCode = 1;
    return;
  }

  const failures: Array<{ route: string; exitCode: number }> = [];
  const flakes: Array<{ route: string; firstExitCode: number }> = [];

  console.log(`Docs routes to check: ${routes.length}`);

  for (let i = 0; i < routes.length; i += 1) {
    const route = routes[i];
    if (!route) continue;

    const label = `[${i + 1}/${routes.length}] ${route}`;
    console.log(`\n${label}`);

    const baseArgs = [
      "check:violations",
      "--",
      "--headless",
      ...(opts.snaps ? ["--snaps-focus"] : []),
      ...(opts.withInspector ? [] : ["--no-inspector"]),
      route,
    ];

    const res = run("pnpm", baseArgs, { quiet: true });

    if (res.ok) {
      process.stdout.write("OK\n");
      continue;
    }

    // Re-run with an ObservationLog for reproducible evidence.
    const slug = routeSlug(route);
    const outDir = path.join(
      process.cwd(),
      "tmp",
      "check-violations",
      "docs-pages",
      slug,
    );
    fs.mkdirSync(outDir, { recursive: true });

    const logPath = path.join(outDir, "observation-log.json");
    const outPath = path.join(outDir, "run-output.txt");
    const firstOutPath = path.join(outDir, "run-output.first.txt");

    fs.writeFileSync(
      firstOutPath,
      [
        `Route: ${route}`,
        `Exit: ${res.status}`,
        "",
        "STDOUT:",
        res.stdout,
        "",
        "STDERR:",
        res.stderr,
      ].join("\n"),
      "utf8",
    );

    const resWithLog = run(
      "pnpm",
      [
        "check:violations",
        "--",
        "--headless",
        ...(opts.snaps ? ["--snaps-focus"] : []),
        ...(opts.withInspector ? [] : ["--no-inspector"]),
        "--log",
        logPath,
        route,
      ],
      { quiet: true },
    );

    fs.writeFileSync(
      outPath,
      [
        `Route: ${route}`,
        `Exit: ${resWithLog.status}`,
        "",
        "STDOUT:",
        resWithLog.stdout,
        "",
        "STDERR:",
        resWithLog.stderr,
      ].join("\n"),
      "utf8",
    );

    if (resWithLog.ok) {
      process.stdout.write("OK (after retry)\n");
      flakes.push({ route, firstExitCode: res.status });
      console.log(
        `Wrote flake artifacts: ${path.relative(process.cwd(), outDir)}`,
      );
      continue;
    }

    process.stdout.write("FAIL\n");
    failures.push({ route, exitCode: resWithLog.status });
    console.log(
      `Wrote failure artifacts: ${path.relative(process.cwd(), outDir)}`,
    );
  }

  if (failures.length > 0) {
    console.log("\nFailures:");
    for (const f of failures) {
      console.log(`- ${f.route} (exit ${f.exitCode})`);
    }
    process.exitCode = 1;
    return;
  }

  if (flakes.length > 0) {
    console.log("\nFlaky routes (passed on retry):");
    for (const flake of flakes) {
      console.log(`- ${flake.route} (initial exit ${flake.firstExitCode})`);
    }
  }

  console.log("\nAll docs routes passed snaps check.");
}

await main();
