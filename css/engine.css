/*
   BASELINE 2025: FULL ENGINE
   The core logic for the "Reactive Pipeline".
*/

@property --_axm-base-chroma {
  syntax: "<number>";
  initial-value: 0.008;
  inherits: true;
}

@property --_axm-base-hue {
  syntax: "<number>";
  initial-value: 0;
  inherits: true;
}

@property --_axm-hue-brand {
  syntax: "<number>";
  initial-value: 0;
  inherits: true;
}

@property --_axm-chroma-brand {
  syntax: "<number>";
  initial-value: 0;
  inherits: true;
}

@property --_axm-surface-transparency {
  syntax: "<percentage>";
  initial-value: 0%;
  inherits: true;
}

@property --_axm-surface-chroma-adjust {
  syntax: "<number>";
  initial-value: 0;
  inherits: true;
}

@property --_axm-hue-adjust {
  syntax: "<number>";
  initial-value: 0;
  inherits: true;
}

/* 
   Overrides are NOT registered as @property because we rely on var() fallbacks.
   If we registered them with an initial-value, the fallback would never trigger.
*/

/*
@property --surface-lightness {
  syntax: "<number>";
  inherits: true;
  initial-value: 1;
}

@property --surface-text-lightness {
  syntax: "<number>";
  inherits: true;
  initial-value: 0;
}
*/

@property --_axm-computed-surface {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

@property --_axm-computed-fg-color {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

/*
@property --computed-border-color {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}
*/

@property --_axm-computed-surface-C {
  syntax: "<number>";
  inherits: true;
  initial-value: 0;
}

@property --_axm-computed-surface-H {
  syntax: "<number>";
  inherits: true;
  initial-value: 0;
}

@property --_axm-computed-fg-C {
  syntax: "<number>";
  inherits: true;
  initial-value: 0;
}

@property --_axm-computed-fg-H {
  syntax: "<number>";
  inherits: true;
  initial-value: 0;
}

@property --_axm-computed-border-alpha {
  syntax: "<number>";
  inherits: true;
  initial-value: 1;
}

@property --_axm-surface-border-alpha {
  syntax: "<number>";
  inherits: true;
  initial-value: 0;
}

:root {
  color-scheme: light dark;

  /* Public Shadow Aliases */
  --shadow-sm: var(--axm-shadow-sm);
  --shadow-md: var(--axm-shadow-md);
  --shadow-lg: var(--axm-shadow-lg);
  --shadow-xl: var(--axm-shadow-xl);
}

/* Proxy tokens that cascade from utilities */
@property --axm-surface-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

@property --axm-text-high-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

@property --axm-text-subtle-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

@property --axm-text-subtlest-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

@property --axm-border-dec-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

@property --axm-border-int-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

@property --_axm-computed-border-dec-color {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

@property --_axm-computed-border-int-color {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}

/*
   THE SURFACE ENGINE
   Matches any element with a class starting with "surface-" or containing " surface-"
   Also matches body to apply the page surface globally.
   Also matches text utilities to ensure they trigger the color calculation.
*/
:where(
  [class^="surface-"],
  [class*=" surface-"],
  [class^="text-"],
  [class*=" text-"],
  body
) {
  /* --- 1. TEXT CALCULATION --- */

  /* 
     Indirection: Lightness Source 
     Defaults to the High Contrast Text Token.
     Utilities like .text-subtle will override this variable.
  */
  --_axm-text-lightness-source: var(--axm-text-high-token);

  /* 
     Indirection: Chroma Source
     Defaults to Base Chroma.
     Utilities like .hue-brand will override this.
  */
  --_axm-text-chroma-source: var(--_axm-base-chroma, 0);

  /* 
     Indirection: Hue Source
     Defaults to Base Hue.
     Utilities like .hue-brand will override this.
  */
  --_axm-text-hue-source: var(--_axm-base-hue, 0);

  /* Calculate Text Chroma */
  /* We use the source chroma, potentially scaled for text legibility if needed */
  --_axm-computed-fg-C: var(
    --_axm-override-fg-chroma,
    calc(var(--_axm-text-chroma-source) * 0.5)
  );

  /* Calculate Text Hue */
  --_axm-computed-fg-H: var(--_axm-default-fg-hue, var(--_axm-text-hue-source));

  /* Reify Text Color */
  /* Extract L from the LIGHTNESS SOURCE, apply computed C and H */
  --_axm-computed-fg-color: oklch(
    from var(--_axm-text-lightness-source) l var(--_axm-computed-fg-C)
      var(--_axm-computed-fg-H)
  );

  /* Apply Text Color */
  color: var(--_axm-computed-fg-color);

  /* --- 2. BORDER CALCULATION --- */

  /* 
     Border Tokens are already valid oklch colors with Alpha.
     We just need to apply our Chroma and Hue to them?
     Wait, the token has L and Alpha. It has 0 Chroma and 0 Hue.
     We want to apply the Text Chroma and Hue to the border.
     
     So we extract L and Alpha, and reconstruct.
  */

  /* Decorative Border */
  /* Extract L and alpha from border token, apply text C and H */
  --_axm-computed-border-dec-color: oklch(
    from var(--axm-border-dec-token) l var(--_axm-computed-fg-C)
      var(--_axm-computed-fg-H) / alpha
  );

  /* Interactive Border */
  --_axm-computed-border-int-color: oklch(
    from var(--axm-border-int-token) l var(--_axm-computed-fg-C)
      var(--_axm-computed-fg-H) / alpha
  );

  /* Default to Decorative */
  border-color: var(--_axm-computed-border-dec-color);
}

/* 
   SURFACE ENGINE & APPLICATION
   Matches ONLY Surfaces and Body.
   Calculates Surface Color and applies Background.
   This prevents text utilities from:
   1. Painting a background.
   2. Corrupting the surface context (Ghost Surfaces).
*/
:where([class^="surface-"], [class*=" surface-"], body) {
  /* --- SURFACE CALCULATION --- */

  /* Calculate Chroma */
  --_axm-computed-surface-C: calc(
    var(--_axm-base-chroma, 0) + var(--_axm-surface-chroma-adjust, 0)
  );

  /* Reify Surface Color */
  /* Extract L and H (Shift) from token, combine with computed C and base hue */
  --_axm-computed-surface: oklch(
    from var(--axm-surface-token) var(--_axm-override-surface-lightness, l)
      var(--_axm-computed-surface-C)
      calc(var(--_axm-base-hue, 0) + var(--_axm-hue-adjust, 0) + h)
  );

  /* --- APPLICATION --- */

  /* Apply Background */
  background-color: var(--_axm-computed-surface);

  /* Apply Scrollbar */
  scrollbar-color: var(--axm-text-subtle-token) var(--axm-surface-token);
}

/* 
   TRANSITIONS
   We only transition the INPUT properties.
   The browser interpolates these numbers, and the :where rule recalculates the colors every frame.
*/
:where(
  [class^="surface-"],
  [class*=" surface-"],
  [class^="state-"],
  [class*=" state-"],
  [class^="text-"],
  [class*=" text-"]
) {
  transition:
    --_axm-computed-surface 0.2s ease-in-out,
    --_axm-computed-fg-color 0.2s ease-in-out,
    --_axm-computed-border-dec-color 0.2s ease-in-out,
    --_axm-computed-border-int-color 0.2s ease-in-out;
}

/* 
   The .bordered utility applies the border.
   It can be used as a standalone class or mixed into a surface.
*/
.bordered {
  border-width: 1px;
  border-style: solid;
}

/* --- FOCUS RINGS --- */

:focus-visible {
  outline: 2px solid
    oklch(
      from var(--_axm-computed-fg-color) l 0.2
        var(--_axm-hue-brand, var(--_axm-base-hue))
    );
  outline-offset: 2px;
}

/* --- HIGHLIGHT & SELECTION --- */

mark {
  background-color: var(--axm-highlight-surface-color);
  color: var(--axm-text-high-token);
}

::selection {
  background-color: var(--axm-highlight-surface-color);
  color: var(--axm-text-high-token);
}

/* --- FORCED COLORS (High Contrast) --- */

@media (forced-colors: active) {
  :root {
    /* 1. Default Mappings (The "Canvas") */
    --_axm-computed-surface: Canvas;
    --_axm-computed-fg-color: CanvasText;
    --_axm-computed-border-color: CanvasText;
  }

  /* 2. Surface Mappings */

  /* Standard Surfaces (Canvas) */
  .surface-card,
  .surface-workspace,
  .surface-tinted,
  .surface-spotlight,
  .surface-soft-spotlight {
    /* Flatten to Canvas, so we enforce a border */
    border: 1px solid CanvasText;

    background-color: Canvas;
    color: CanvasText;

    --_axm-computed-surface: Canvas;
    --_axm-computed-fg-color: CanvasText;
    --_axm-computed-border-color: CanvasText;
  }

  /* Actions (Buttons) */
  .surface-action {
    background-color: ButtonFace;
    color: ButtonText;
    border: 1px solid ButtonText;

    --_axm-computed-surface: ButtonFace;
    --_axm-computed-fg-color: ButtonText;
    --_axm-computed-border-color: ButtonText;
  }

  /* 3. Utility Mappings */

  /* Links */
  .text-link {
    color: LinkText;
  }

  /* Disabled State */
  .state-disabled,
  [disabled] {
    opacity: 1; /* Opacity is ignored, so we rely on color */
    color: GrayText;
    border-color: GrayText;
    --_axm-computed-fg-color: GrayText;
    --_axm-computed-border-color: GrayText;
  }

  /* Selected State */
  .state-selected,
  [aria-selected="true"] {
    background-color: Highlight;
    color: HighlightText;
    border-color: Highlight;
    --_axm-computed-surface: Highlight;
    --_axm-computed-fg-color: HighlightText;
  }

  /* Interactive Borders */
  .border-interactive {
    --_axm-computed-border-color: Highlight;
  }

  /* 4. Global Overrides */

  /* Selection */
  ::selection {
    background-color: Highlight;
    color: HighlightText;
  }

  /* Focus Rings */
  :focus-visible {
    outline-color: Highlight;
  }
}

/* --- PRINT STYLES --- */

@media print {
  :root {
    /* Force Light Mode to save ink */
    color-scheme: light;

    /* Remove Chroma to save color ink */
    --_axm-base-chroma: 0;
    --_axm-surface-chroma-adjust: 0;
    --_axm-hue-adjust: 0;
    --_axm-chroma-brand: 0;
  }

  /* Force white backgrounds for main surfaces */
  .surface-card,
  .surface-workspace,
  .surface-tinted {
    /*
       We use white to simulate the paper color and ensure no background ink is used.
       We do not use 'transparent' to ensure we cover any underlying elements if stacking occurs.
       We do not use !important because the :where() block in the engine has 0 specificity.
    */
    background-color: white;
    --_axm-computed-surface: white;

    /* Add a subtle border to define the surface since the background is gone */
    border: 1px solid var(--axm-text-subtlest-token);
  }

  /* Ensure text is dark (Black ink) */
  body {
    color: black;
  }

  /* Hide purely interactive elements */
  /* We assume .surface-action is a button/control */
  .surface-action {
    display: none;
  }
}
